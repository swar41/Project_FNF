

Helpers

Helpers/JwtHelper.cs----------

using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using Project_Version1.Data;

namespace Project_Version1.Helpers
{
    public class JwtHelper
    {
        private readonly IConfiguration _config;
        public JwtHelper(IConfiguration config) => _config = config;

        public string GenerateToken(User user)
        {
            var jwt = _config.GetSection("Jwt");
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwt["Key"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, user.UserId.ToString()),
                new Claim(ClaimTypes.Name, user.FullName ?? string.Empty),
                new Claim(ClaimTypes.Email, user.Email ?? string.Empty),
                new Claim(ClaimTypes.Role, user.Role ?? "Employee"),
                new Claim("DeptId", user.DepartmentId?.ToString() ?? string.Empty)
            };

            var token = new JwtSecurityToken(
                issuer: jwt["Issuer"],
                audience: jwt["Audience"],
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(jwt["ExpireMinutes"] ?? "1440")),
                signingCredentials: creds
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}

Helpers/PasswordHasher.cs

using System;
using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using System.Security.Cryptography;

namespace Project_Version1.Helpers
{
    public static class PasswordHasher
    {
        // Produces salted hash: salt.hash
        public static string Hash(string password)
        {
            byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
            string saltStr = Convert.ToBase64String(salt);
            var hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: password,
                salt: salt,
                prf: KeyDerivationPrf.HMACSHA256,
                iterationCount: 100_000,
                numBytesRequested: 256 / 8));

            return $"{saltStr}.{hashed}";
        }

        public static bool Verify(string password, string stored)
        {
            if (string.IsNullOrWhiteSpace(stored)) return false;
            var parts = stored.Split('.');
            if (parts.Length != 2) return false;
            var salt = Convert.FromBase64String(parts[0]);
            var expected = parts[1];

            var hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: password,
                salt: salt,
                prf: KeyDerivationPrf.HMACSHA256,
                iterationCount: 100_000,
                numBytesRequested: 256 / 8));

            return hashed == expected;
        }
    }
}

Helpers/PaginationHelper.cs

using System;
using System.Linq;

namespace Project_Version1.Helpers
{
    public static class PaginationHelper
    {
        public static IQueryable<T> Paginate<T>(IQueryable<T> query, int page, int pageSize)
        {
            if (page < 1) page = 1;
            if (pageSize < 1) pageSize = 20;
            return query.Skip((page - 1) * pageSize).Take(pageSize);
        }
    }
}

Helpers/SignalRHub.cs

using Microsoft.AspNetCore.SignalR;
using System.Threading.Tasks;

namespace Project_Version1.Helpers
{
    public class NotificationHub : Hub
    {
        public async Task SendToUser(string userId, string message)
        {
            await Clients.User(userId).SendAsync("ReceiveNotification", message);
        }

        public async Task Broadcast(string message)
        {
            await Clients.All.SendAsync("ReceiveNotification", message);
        }
    }
}


---

DTOs

DTOs/AuthDtos.cs

namespace Project_Version1.DTOs
{
    public class RegisterDto
    {
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string Role { get; set; } = "Employee";
        public int? DepartmentId { get; set; }
    }

    public class LoginDto
    {
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
    }

    public class AuthResponseDto
    {
        public string Token { get; set; } = null!;
        public int UserId { get; set; }
        public string Role { get; set; } = null!;
    }
}

DTOs/PostDtos.cs

using System;
using System.Collections.Generic;

namespace Project_Version1.DTOs
{
    public class PostCreateDto
    {
        public int DeptId { get; set; }
        public string Title { get; set; } = null!;
        public string Body { get; set; } = null!;
        public List<string>? Tags { get; set; }
    }

    public class PostUpdateDto
    {
        public string? Title { get; set; }
        public string? Body { get; set; }
    }

    public class PostBriefDto
    {
        public int PostId { get; set; }
        public string Title { get; set; } = null!;
        public string BodyPreview { get; set; } = null!;
        public int UpvoteCount { get; set; }
        public int DownvoteCount { get; set; }
        public int CommentsCount { get; set; }
        public DateTime CreatedAt { get; set; }
        public string? AuthorName { get; set; }
    }
}

DTOs/CommentDtos.cs

using System;

namespace Project_Version1.DTOs
{
    public class CommentCreateDto
    {
        public int PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
    }

    public class CommentDto
    {
        public int CommentId { get; set; }
        public int PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
        public string? AuthorName { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}

DTOs/VoteDtos.cs

namespace Project_Version1.DTOs
{
    public class VoteDto
    {
        public int? PostId { get; set; }
        public int? CommentId { get; set; }
        public string VoteType { get; set; } = "Upvote"; // "Upvote" or "Downvote"
    }
}

DTOs/UserDtos.cs

namespace Project_Version1.DTOs
{
    public class UserDto
    {
        public int UserId { get; set; }
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Role { get; set; } = null!;
        public int? DepartmentId { get; set; }
        public string? ProfilePicture { get; set; }
    }

    public class UserCreateDto
    {
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string Role { get; set; } = "Employee";
        public int? DepartmentId { get; set; }
    }
}


---

Services

> All services use FnfKnowledgeBaseContext from your scaffolded file.



Services/AuthService.cs

using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;
using Project_Version1.Helpers;

namespace Project_Version1.Services
{
    public class AuthService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly JwtHelper _jwt;
        public AuthService(FnfKnowledgeBaseContext db, JwtHelper jwt) { _db = db; _jwt = jwt; }

        public async Task<AuthResponseDto?> RegisterAsync(RegisterDto dto)
        {
            var exists = await _db.Users.AnyAsync(u => u.Email == dto.Email);
            if (exists) return null;

            var user = new User
            {
                FullName = dto.FullName,
                Email = dto.Email,
                PasswordHash = PasswordHasher.Hash(dto.Password),
                Role = dto.Role,
                DepartmentId = dto.DepartmentId
            };

            _db.Users.Add(user);
            await _db.SaveChangesAsync();

            var token = _jwt.GenerateToken(user);
            return new AuthResponseDto { Token = token, UserId = user.UserId, Role = user.Role ?? "Employee" };
        }

        public async Task<AuthResponseDto?> LoginAsync(LoginDto dto)
        {
            var user = await _db.Users.FirstOrDefaultAsync(u => u.Email == dto.Email);
            if (user == null) return null;
            if (!PasswordHasher.Verify(dto.Password, user.PasswordHash)) return null;

            var token = _jwt.GenerateToken(user);
            return new AuthResponseDto { Token = token, UserId = user.UserId, Role = user.Role ?? "Employee" };
        }
    }
}

Services/PostService.cs

using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class PostService
    {
        private readonly FnfKnowledgeBaseContext _db;
        public PostService(FnfKnowledgeBaseContext db) { _db = db; }

        public async Task<Post> CreatePostAsync(PostCreateDto dto, int userId)
        {
            var post = new Post
            {
                UserId = userId,
                DeptId = dto.DeptId,
                Title = dto.Title,
                Body = dto.Body,
                CreatedAt = DateTime.Now
            };

            _db.Posts.Add(post);
            await _db.SaveChangesAsync();

            if (dto.Tags != null && dto.Tags.Any())
            {
                foreach (var t in dto.Tags.Distinct())
                {
                    var tag = await _db.Tags.FirstOrDefaultAsync(x => x.TagName == t && x.DeptId == dto.DeptId);
                    if (tag == null)
                    {
                        tag = new Tag { TagName = t, DeptId = dto.DeptId };
                        _db.Tags.Add(tag);
                        await _db.SaveChangesAsync();
                    }
                    _db.PostTags.Add(new PostTag { PostId = post.PostId, TagId = tag.TagId });
                }
                await _db.SaveChangesAsync();
            }

            return post;
        }

        public IQueryable<Post> QueryPosts() =>
            _db.Posts
               .Include(p => p.User)
               .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)
               .Include(p => p.Comments)
               .Include(p => p.Reposts);

        public async Task<Post?> GetPostAsync(int id) =>
            await _db.Posts
                .Include(p => p.User)
                .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)
                .Include(p => p.Comments).ThenInclude(c => c.User)
                .Include(p => p.Attachments)
                .FirstOrDefaultAsync(p => p.PostId == id);

        public async Task UpdatePostAsync(Post post) 
        {
            post.UpdatedAt = DateTime.Now;
            _db.Posts.Update(post);
            await _db.SaveChangesAsync();
        }

        public async Task DeletePostAsync(Post post)
        {
            _db.Posts.Remove(post);
            await _db.SaveChangesAsync();
        }

        public async Task RepostAsync(int postId, int userId)
        {
            var exists = await _db.Reposts.AnyAsync(r => r.PostId == postId && r.UserId == userId);
            if (exists) return;
            var repost = new Repost { PostId = postId, UserId = userId, CreatedAt = DateTime.Now };
            _db.Reposts.Add(repost);
            await _db.SaveChangesAsync();
        }
    }
}

Services/CommentService.cs

using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class CommentService
    {
        private readonly FnfKnowledgeBaseContext _db;
        public CommentService(FnfKnowledgeBaseContext db) { _db = db; }

        public async Task<Comment> AddCommentAsync(CommentCreateDto dto, int userId)
        {
            var comment = new Comment
            {
                PostId = dto.PostId,
                ParentCommentId = dto.ParentCommentId,
                UserId = userId,
                CommentText = dto.CommentText,
                CreatedAt = DateTime.Now
            };
            _db.Comments.Add(comment);
            await _db.SaveChangesAsync();
            return comment;
        }

        public IQueryable<Comment> QueryCommentsForPost(int postId) =>
            _db.Comments
               .Where(c => c.PostId == postId)
               .Include(c => c.User)
               .Include(c => c.InverseParentComment);

        public async Task DeleteCommentAsync(Comment comment)
        {
            _db.Comments.Remove(comment);
            await _db.SaveChangesAsync();
        }
    }
}

Services/VoteService.cs

using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class VoteService
    {
        private readonly FnfKnowledgeBaseContext _db;
        public VoteService(FnfKnowledgeBaseContext db) { _db = db; }

        public async Task<bool> VoteAsync(VoteDto dto, int userId)
        {
            if (dto.PostId == null && dto.CommentId == null) return false;

            // Ensure single vote per user per target
            var existing = await _db.Votes.FirstOrDefaultAsync(v =>
                v.UserId == userId &&
                v.PostId == dto.PostId &&
                v.CommentId == dto.CommentId);

            if (existing != null)
            {
                // toggle or change
                if (existing.VoteType == dto.VoteType)
                {
                    _db.Votes.Remove(existing);
                }
                else
                {
                    existing.VoteType = dto.VoteType;
                    existing.CreatedAt = DateTime.Now;
                    _db.Votes.Update(existing);
                }
            }
            else
            {
                var vote = new Vote
                {
                    PostId = dto.PostId,
                    CommentId = dto.CommentId,
                    UserId = userId,
                    VoteType = dto.VoteType,
                    CreatedAt = DateTime.Now
                };
                _db.Votes.Add(vote);
            }

            await _db.SaveChangesAsync();
            // Update counters (best-effort)
            if (dto.PostId.HasValue)
            {
                var pid = dto.PostId.Value;
                var up = await _db.Votes.CountAsync(v => v.PostId == pid && v.VoteType == "Upvote");
                var down = await _db.Votes.CountAsync(v => v.PostId == pid && v.VoteType == "Downvote");
                var post = await _db.Posts.FindAsync(pid);
                if (post != null)
                {
                    post.UpvoteCount = up;
                    post.DownvoteCount = down;
                    _db.Posts.Update(post);
                    await _db.SaveChangesAsync();
                }
            }

            return true;
        }
    }
}

Services/NotificationService.cs

using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR;
using Project_Version1.Data;
using Project_Version1.Helpers;

namespace Project_Version1.Services
{
    public class NotificationService
    {
        private readonly IHubContext<NotificationHub> _hub;
        private readonly FnfKnowledgeBaseContext _db;
        public NotificationService(IHubContext<NotificationHub> hub, FnfKnowledgeBaseContext db)
        {
            _hub = hub; _db = db;
        }

        public async Task NotifyUserAsync(int userId, string message)
        {
            // you might persist notifications to DB table in future
            await _hub.Clients.User(userId.ToString()).SendAsync("ReceiveNotification", message);
        }

        public async Task BroadcastAsync(string message)
        {
            await _hub.Clients.All.SendAsync("ReceiveNotification", message);
        }
    }
}

Services/FileService.cs (basic)

using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Project_Version1.Data;

namespace Project_Version1.Services
{
    public class FileService
    {
        private readonly IWebHostEnvironment _env;
        public FileService(IWebHostEnvironment env) => _env = env;

        public async Task<(string fileName, string filePath)> SaveFileAsync(IFormFile file)
        {
            var uploads = Path.Combine(_env.WebRootPath ?? "wwwroot", "uploads");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            var fileName = $"{Guid.NewGuid()}_{Path.GetFileName(file.FileName)}";
            var filePath = Path.Combine(uploads, fileName);

            using (var fs = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(fs);
            }

            var relativePath = $"/uploads/{fileName}";
            return (fileName, relativePath);
        }
    }
}


---

Controllers

> All controllers use attribute routing, basic authorization where appropriate. Adjust CORS & authentication in Program.cs.



Controllers/AuthController.cs

using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly AuthService _auth;
        public AuthController(AuthService auth) => _auth = auth;

        [HttpPost("register")]
        public async Task<IActionResult> Register(RegisterDto dto)
        {
            var res = await _auth.RegisterAsync(dto);
            if (res == null) return Conflict(new { message = "Email already exists" });
            return Ok(res);
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(LoginDto dto)
        {
            var res = await _auth.LoginAsync(dto);
            if (res == null) return Unauthorized(new { message = "Invalid credentials" });
            return Ok(res);
        }
    }
}

Controllers/UsersController.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Linq;
using System.Threading.Tasks;
using Project_Version1.Data;
using Project_Version1.DTOs;
using Microsoft.EntityFrameworkCore;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class UsersController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        public UsersController(FnfKnowledgeBaseContext db) { _db = db; }

        [HttpGet]
        public async Task<IActionResult> GetAll()
        {
            var users = await _db.Users
                .Select(u => new UserDto {
                    UserId = u.UserId, FullName = u.FullName, Email = u.Email,
                    Role = u.Role, DepartmentId = u.DepartmentId, ProfilePicture = u.ProfilePicture
                }).ToListAsync();

            return Ok(users);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> Get(int id)
        {
            var u = await _db.Users.FindAsync(id);
            if (u == null) return NotFound();
            var dto = new UserDto { UserId = u.UserId, FullName = u.FullName, Email = u.Email, Role = u.Role, DepartmentId = u.DepartmentId, ProfilePicture = u.ProfilePicture };
            return Ok(dto);
        }
    }
}

Controllers/PostsController.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;
using Project_Version1.Data;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Helpers;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class PostsController : ControllerBase
    {
        private readonly PostService _postService;
        private readonly FnfKnowledgeBaseContext _db;
        public PostsController(PostService postService, FnfKnowledgeBaseContext db)
        {
            _postService = postService; _db = db;
        }

        [HttpGet("feed")]
        public async Task<IActionResult> Feed([FromQuery] int? deptId, [FromQuery] string? tag, [FromQuery] int page = 1, [FromQuery] int pageSize = 20)
        {
            var q = _postService.QueryPosts();

            if (deptId.HasValue) q = q.Where(p => p.DeptId == deptId.Value);
            if (!string.IsNullOrEmpty(tag)) q = q.Where(p => p.PostTags.Any(pt => pt.Tag.TagName == tag));

            q = q.OrderByDescending(p => (p.UpvoteCount ?? 0) + (p.Comments != null ? p.Comments.Count : 0));
            var paged = PaginationHelper.Paginate(q, page, pageSize);

            var list = await paged.Select(p => new PostBriefDto
            {
                PostId = p.PostId,
                Title = p.Title,
                BodyPreview = p.Body.Length > 200 ? p.Body.Substring(0, 200) + "..." : p.Body,
                UpvoteCount = p.UpvoteCount ?? 0,
                DownvoteCount = p.DownvoteCount ?? 0,
                CommentsCount = p.Comments != null ? p.Comments.Count : 0,
                CreatedAt = p.CreatedAt,
                AuthorName = p.User.FullName
            }).ToListAsync();

            return Ok(list);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> Get(int id)
        {
            var post = await _postService.GetPostAsync(id);
            if (post == null) return NotFound();
            return Ok(post);
        }

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Create([FromBody] PostCreateDto dto)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            var post = await _postService.CreatePostAsync(dto, userId);
            return CreatedAtAction(nameof(Get), new { id = post.PostId }, post);
        }

        [Authorize]
        [HttpPut("{id}")]
        public async Task<IActionResult> Update(int id, [FromBody] PostUpdateDto dto, [FromQuery] string? commitMessage = null)
        {
            var post = await _db.Posts.FindAsync(id);
            if (post == null) return NotFound();

            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role == "Manager")
            {
                // check manager exists for dept
                var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == post.DeptId);
                if (manager == null) return Forbid();
                if (!string.IsNullOrEmpty(commitMessage))
                {
                    _db.Commits.Add(new Commit { PostId = id, ManagerId = manager.ManagerId, Message = commitMessage });
                }
            }
            else if (post.UserId != userId)
            {
                return Forbid();
            }

            if (!string.IsNullOrEmpty(dto.Title)) post.Title = dto.Title;
            if (!string.IsNullOrEmpty(dto.Body)) post.Body = dto.Body;
            post.UpdatedAt = System.DateTime.Now;
            _db.Posts.Update(post);
            await _db.SaveChangesAsync();
            return NoContent();
        }

        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id, [FromQuery] string? commitMessage = null)
        {
            var post = await _db.Posts.FindAsync(id);
            if (post == null) return NotFound();

            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role == "Manager")
            {
                var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == post.DeptId);
                if (manager == null) return Forbid();
                if (!string.IsNullOrEmpty(commitMessage))
                {
                    _db.Commits.Add(new Commit { PostId = id, ManagerId = manager.ManagerId, Message = commitMessage });
                }
            }
            else if (post.UserId != userId)
            {
                return Forbid();
            }

            _db.Posts.Remove(post);
            await _db.SaveChangesAsync();
            return NoContent();
        }

        [Authorize]
        [HttpPost("{id}/repost")]
        public async Task<IActionResult> Repost(int id)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            await _postService.RepostAsync(id, userId);
            return Ok();
        }
    }
}

Controllers/CommentsController.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;
using Project_Version1.Data;
using Microsoft.EntityFrameworkCore;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CommentsController : ControllerBase
    {
        private readonly CommentService _commentService;
        private readonly FnfKnowledgeBaseContext _db;
        public CommentsController(CommentService commentService, FnfKnowledgeBaseContext db)
        {
            _commentService = commentService; _db = db;
        }

        [HttpGet("post/{postId}")]
        public IActionResult GetForPost(int postId)
        {
            var comments = _commentService.QueryCommentsForPost(postId)
                .Select(c => new CommentDto
                {
                    CommentId = c.CommentId,
                    PostId = c.PostId,
                    ParentCommentId = c.ParentCommentId,
                    CommentText = c.CommentText,
                    AuthorName = c.User.FullName,
                    CreatedAt = c.CreatedAt
                });
            return Ok(comments);
        }

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Create([FromBody] CommentCreateDto dto)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            var comment = await _commentService.AddCommentAsync(dto, userId);
            return CreatedAtAction(nameof(GetForPost), new { postId = dto.PostId }, comment);
        }

        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id)
        {
            var comment = await _db.Comments.Include(c => c.User).FirstOrDefaultAsync(c => c.CommentId == id);
            if (comment == null) return NotFound();
            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role == "Manager")
            {
                var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == comment.Post.DeptId);
                if (manager == null) return Forbid();
                _db.Commits.Add(new Commit { PostId = comment.PostId, ManagerId = manager.ManagerId, Message = $"Deleted comment {id}" });
            }
            else if (comment.UserId != userId)
            {
                return Forbid();
            }

            await _commentService.DeleteCommentAsync(comment);
            return NoContent();
        }
    }
}

Controllers/VotesController.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class VotesController : ControllerBase
    {
        private readonly VoteService _voteService;
        public VotesController(VoteService voteService) => _voteService = voteService;

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Vote([FromBody] VoteDto dto)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            var ok = await _voteService.VoteAsync(dto, userId);
            if (!ok) return BadRequest();
            return Ok();
        }
    }
}

Controllers/CategoriesController.cs

using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using Project_Version1.Data;
using Microsoft.EntityFrameworkCore;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CategoriesController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        public CategoriesController(FnfKnowledgeBaseContext db) => _db = db;

        [HttpGet]
        public async Task<IActionResult> GetAll() =>
            Ok(await _db.Departments.Select(d => new { d.DeptId, d.DeptName }).ToListAsync());
    }
}

Controllers/TagsController.cs

using Microsoft.AspNetCore.Mvc;
using System.Linq;
using System.Threading.Tasks;
using Project_Version1.Data;
using Microsoft.EntityFrameworkCore;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TagsController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        public TagsController(FnfKnowledgeBaseContext db) => _db = db;

        [HttpGet]
        public async Task<IActionResult> Get([FromQuery] int? deptId)
        {
            var q = _db.Tags.AsQueryable();
            if (deptId.HasValue) q = q.Where(t => t.DeptId == deptId.Value);
            var list = await q.Select(t => new { t.TagId, t.TagName, t.DeptId }).ToListAsync();
            return Ok(list);
        }
    }
}

Controllers/NotificationsController.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using Project_Version1.Services;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class NotificationsController : ControllerBase
    {
        private readonly NotificationService _notification;
        public NotificationsController(NotificationService notification) => _notification = notification;

        [HttpPost("broadcast")]
        public async Task<IActionResult> Broadcast([FromBody] string message)
        {
            await _notification.BroadcastAsync(message);
            return Ok();
        }
    }
}


---

Program.cs (registration guidance)

Add these service registrations and auth setup in your Program.cs:

using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using Project_Version1.Helpers;
using Project_Version1.Services;
using Project_Version1.Data;

var builder = WebApplication.CreateBuilder(args);

// DbContext
builder.Services.AddDbContext<FnfKnowledgeBaseContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("FNF_KnowledgeBase")));

// Helpers & Services
builder.Services.AddScoped<JwtHelper>();
builder.Services.AddScoped<AuthService>();
builder.Services.AddScoped<PostService>();
builder.Services.AddScoped<CommentService>();
builder.Services.AddScoped<VoteService>();
builder.Services.AddScoped<NotificationService>();
builder.Services.AddScoped<FileService>();

// SignalR
builder.Services.AddSignalR();

// Controllers
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// JWT
var jwt = builder.Configuration.GetSection("Jwt");
builder.Services.AddAuthentication(options =>
{
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = jwt["Issuer"],
        ValidAudience = jwt["Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwt["Key"]))
    };
});

builder.Services.AddAuthorization();
builder.Services.AddCors(o => o.AddPolicy("dev", p => p.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader()));

var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseCors("dev");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.MapHub<NotificationHub>("/hubs/notifications");
app.Run();

Add a Jwt configuration in appsettings.json:

"Jwt": {
  "Key": "YourVeryStrongSecretKeyReplaceThis_32plusChars",
  "Issuer": "FNFIndia",
  "Audience": "FNFIndiaUsers",
  "ExpireMinutes": "1440"
}




