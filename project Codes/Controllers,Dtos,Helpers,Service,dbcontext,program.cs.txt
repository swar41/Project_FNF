// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Program.cs

using AutoMapper;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using Project_Version1.Data;
using Project_Version1.Helpers;
using Microsoft.OpenApi.Models;
using Project_Version1.Services;
using System.Text;
using Project_Version1.Profiles;
using Project_Version1.Hubs;
using Microsoft.AspNetCore.SignalR;

var builder = WebApplication.CreateBuilder(args);

// DbContext
builder.Services.AddDbContext<FnfKnowledgeBaseContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("myCon")));
// AutoMapper
builder.Services.AddAutoMapper(cfg => { cfg.AddMaps(typeof(MappingProfile).Assembly); });
// Helpers & Services
builder.Services.AddScoped<JwtHelper>();
builder.Services.AddScoped<AuthService>();
builder.Services.AddScoped<VoteService>(); // Make sure this comes before CommentService
builder.Services.AddScoped<CommentService>(); // Now depends on VoteService
builder.Services.AddScoped<PostService>();
//builder.Services.AddScoped<NotificationService>();

builder.Services.AddScoped<FileService>();


// SignalR
builder.Services.AddSignalR();
builder.Services.AddSingleton<IUserIdProvider, NameIdentifierUserIdProvider>();


// Controllers
builder.Services.AddControllers().AddJsonOptions(options =>{

        options.JsonSerializerOptions.ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.IgnoreCycles;
        options.JsonSerializerOptions.WriteIndented = true;
    });
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "FNF KnowledgeBase API", Version = "v1" });

    // ?? Add JWT Bearer definition
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer",
        BearerFormat = "JWT",
        In = ParameterLocation.Header,
        Description = "Enter 'Bearer' [space] and then your token.\n\nExample: \"Bearer abc123xyz\""
    });

    // ?? Require JWT for all endpoints by default
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

// JWT
var jwt = builder.Configuration.GetSection("Jwt");
builder.Services.AddAuthentication(options =>
{
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = jwt["Issuer"],
        ValidAudience = jwt["Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwt["Key"]))
    };
});
    
// Replace this line:
// builder.Services.AddAutoMapper(typeof(Program).Assembly);

// With this line:
builder.Services.AddAuthorization();
builder.Services.AddCors(o => o.AddPolicy("dev", p => p.WithOrigins("http://localhost:3001", "http://localhost:3000").AllowAnyMethod().AllowAnyHeader().AllowCredentials()));

var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
var uploadsDir = Path.Combine(app.Environment.WebRootPath ??Path.Combine(Directory.GetCurrentDirectory(), "wwwroot"),"uploads","attachments");
app.UseCors("dev");
app.UseStaticFiles(); // enables serving from wwwroot

app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.MapHub<NotificationHub>("/hubs/notifications");

app.Run();

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\AuthController.cs
﻿
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly AuthService _auth;
        public AuthController(AuthService auth) => _auth = auth;


        [HttpPost("register")]
        public async Task<IActionResult> Register([FromForm] RegisterDto dto)
        {
            var res = await _auth.RegisterAsync(dto);
            if (res == null) return Conflict(new { message = "Email already exists" });
            return Ok(res);
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(LoginDto dto)
        {
            var res = await _auth.LoginAsync(dto);
            if (res == null) return Unauthorized(new { message = "Invalid credentials" });
            return Ok(res);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\CategoriesController.cs
﻿using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CategoriesController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public CategoriesController(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        [HttpGet]
        public async Task<IActionResult> GetAll()
        {
            var departments = await _db.Departments
                .ProjectTo<DepartmentDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
            return Ok(departments);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\CommentsController.cs
﻿
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Services;
using Project_Version1.DTOs;
using Project_Version1.Data;
using Project_Version1.Hubs;
using Microsoft.AspNetCore.SignalR;

using System;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CommentsController : ControllerBase
    {
        private readonly CommentService _commentService;
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IHubContext<NotificationHub> _hub;
        public CommentsController(CommentService commentService, FnfKnowledgeBaseContext db, IHubContext<NotificationHub> hub)
        {
            _commentService = commentService;
            _db = db;
            _hub = hub;
        }

        [HttpGet("post/{postId}")]
        public async Task<IActionResult> GetForPost(int postId, [FromQuery] bool hierarchical = false)
        {
            try
            {
                int? currentUserId = null;
                if (User.Identity?.IsAuthenticated == true)
                {
                    var userIdClaim = User.FindFirstValue(ClaimTypes.NameIdentifier);
                    if (userIdClaim != null && int.TryParse(userIdClaim, out var userId))
                    {
                        currentUserId = userId;
                    }
                }

                if (hierarchical)
                {
                    var hierarchicalComments = await _commentService.GetCommentsHierarchyAsync(postId, currentUserId);
                    return Ok(hierarchicalComments);
                }
                else
                {
                    var comments = await _commentService.GetCommentsForPostAsync(postId, currentUserId);
                    return Ok(comments);
                }
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        [HttpGet("{commentId}")]
        public async Task<IActionResult> GetComment(int commentId)
        {
            try
            {
                int? currentUserId = null;
                if (User.Identity?.IsAuthenticated == true)
                {
                    var userIdClaim = User.FindFirstValue(ClaimTypes.NameIdentifier);
                    if (userIdClaim != null && int.TryParse(userIdClaim, out var userId))
                    {
                        currentUserId = userId;
                    }
                }

                var comment = await _commentService.GetCommentWithVotesAsync(commentId, currentUserId);
                if (comment == null) return NotFound();

                return Ok(comment);
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Create([FromBody] CommentCreateDto dto)
        {
            try
            {
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
                var comment = await _commentService.AddCommentAsync(dto, userId);
                if (comment == null)
                {
                    return BadRequest(new { message = "Failed to create comment" });
                }

                var commentWithVotes = await _commentService.GetCommentWithVotesAsync(comment.CommentId, userId);
                return CreatedAtAction(nameof(GetComment), new { commentId = comment.CommentId }, commentWithVotes);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(new { message = ex.Message });
            }
            catch (Exception)
            {
                return StatusCode(500, new { message = "An error occurred while creating the comment" });
            }
        }

        // === MODIFIED DELETE: allow owner deletion; manager deletion with commit message ===
        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id, [FromQuery] string? commitMessage = null)
        {
            try
            {
                var comment = await _commentService.GetCommentAsync(id);
                if (comment == null) return NotFound();

                var role = User.FindFirstValue(ClaimTypes.Role);
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

                if (role == "Manager")
                {
                    var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == comment.Post.DeptId);
                    if (manager == null) return Forbid();

                    if (!string.IsNullOrEmpty(commitMessage))
                    {
                        _db.Commits.Add(new Commit
                        {
                            PostId = comment.PostId,
                            ManagerId = manager.ManagerId,
                            Message = commitMessage,
                            CreatedAt = DateTime.UtcNow
                        });
                        await _hub.Clients.User(comment.UserId.ToString())
                           .SendAsync("ReceiveNotification", new
                           {
                               Type = "CommentDeletion",
                               PostId = comment.PostId,
                               CommentId = comment.CommentId,
                               CommitMessage = commitMessage,
                               Manager = manager.User.FullName,
                               Timestamp = DateTime.UtcNow
                           });
                    }

                    // Manager: force delete (includes replies if service handles that)
                    await _commentService.ForceDeleteCommentAsync(comment);
                    await _db.SaveChangesAsync();
                    return NoContent();
                }
                else if (comment.UserId == userId)
                {
                    // Owner deletes own comment (soft or normal delete depending on service)
                    await _commentService.DeleteCommentAsync(comment);
                    //await _db.SaveChangesAsync();
                    return NoContent();
                }
                else
                {
                    return Forbid();
                }
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        [Authorize]
        [HttpPut("{id}")]
        public async Task<IActionResult> Update(int id, [FromBody] CommentUpdateDto dto, [FromQuery] string? commitMessage = null)
        {
            try
            {
                var comment = await _commentService.GetCommentAsync(id);
                if (comment == null) return NotFound();

                var role = User.FindFirstValue(ClaimTypes.Role);
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

                if (role == "Manager")
                {
                    // Manager can update any comment in their dept
                    var manager = await _db.Managers.FirstOrDefaultAsync(
                        m => m.UserId == userId && m.DeptId == comment.Post.DeptId
                    );
                    if (manager == null) return Forbid();

                    if (!string.IsNullOrEmpty(commitMessage))
                    {
                        _db.Commits.Add(new Commit
                        {
                            PostId = comment.PostId,
                            ManagerId = manager.ManagerId,
                            Message = commitMessage,
                            CreatedAt = DateTime.UtcNow
                        });
                        await _hub.Clients.User(comment.UserId.ToString())
                           .SendAsync("ReceiveNotification", new
                           {
                               Type = "CommentUpdate",
                               PostId = comment.PostId,
                               CommentId = comment.CommentId,
                               CommitMessage = commitMessage,
                               Manager = manager.User.FullName,
                               Timestamp = DateTime.UtcNow
                           });
                    }
                }
                else if (comment.UserId != userId)
                {
                    // Normal users can only update their own comments
                    return Forbid();
                }

                // Perform update
                if (!string.IsNullOrEmpty(dto.CommentText))
                {
                    comment.CommentText = dto.CommentText;
                    comment.UpdatedAt = DateTime.UtcNow;
                }

                await _db.SaveChangesAsync();
                return Ok(new { message = "Comment updated successfully" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\CommitsController.cs
﻿
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using System.Security.Claims;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class CommitsController : ControllerBase
{
    private readonly FnfKnowledgeBaseContext _db;
    public CommitsController(FnfKnowledgeBaseContext db) => _db = db;

    [HttpGet("post/{postId}")]
    public async Task<IActionResult> GetForPost(int postId)
    {
        var commits = await _db.Commits
            .Where(c => c.PostId == postId)
            .Include(c => c.Manager).ThenInclude(m => m.User)
            .OrderByDescending(c => c.CreatedAt)
            .ToListAsync();
        return Ok(commits);
    }

    [Authorize(Roles = "Manager")]
    [HttpGet("mine")]
    public async Task<IActionResult> GetForManager()
    {
        var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
        var commits = await _db.Commits
            .Where(c => c.Manager.UserId == userId)
            .OrderByDescending(c => c.CreatedAt)
            .ToListAsync();
        return Ok(commits);
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\PostsController.cs
﻿using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Services;
using Project_Version1.DTOs;
using Project_Version1.Data;
using AutoMapper;
using System;
using Microsoft.AspNetCore.SignalR;
using Project_Version1.Hubs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class PostsController : ControllerBase
    {
        private readonly PostService _postService;
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;
        private readonly IHubContext<NotificationHub> _hub;

        public PostsController(PostService postService, FnfKnowledgeBaseContext db, IMapper mapper, IHubContext<NotificationHub> hub)
        {
            _postService = postService;
            _db = db;
            _mapper = mapper;
            _hub = hub;
        }

        [HttpGet("feed")]
        public async Task<IActionResult> Feed(
            [FromQuery] int? deptId,
            [FromQuery] string? tag,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 20)
        {
            var posts = await _postService.GetPostsFeedAsync(deptId, tag, page, pageSize);
            return Ok(posts);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> Get(int id)
        {
            var post = await _postService.GetPostAsync(id);
            if (post == null) return NotFound();

            var postDto = _mapper.Map<PostDetailDto>(post);
            return Ok(postDto);
        }

        [Authorize]
        [HttpGet("mine")]
        public async Task<IActionResult> GetMyPosts()
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            var posts = await _postService.GetPostsByUserAsync(userId);
            return Ok(posts);
        }

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Create([FromForm] PostCreateDto dto)
        {
            try
            {
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

                // assign dept id from user if not provided
                if (dto.DeptId == 0)
                {
                    var user = await _db.Users.FirstOrDefaultAsync(u => u.UserId == userId);
                    if (user == null || user.DepartmentId == 0) return BadRequest("User department information is missing.");
                    dto.DeptId = user.DepartmentId;
                }

                var post = await _postService.CreatePostAsync(dto, userId, dto.DeptId);
                if (post == null) return BadRequest(new { message = "Failed to create post" });

                return CreatedAtAction(nameof(Get), new { id = post.PostId }, post);
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        [Authorize]
        [HttpPut("{id}")]
        public async Task<IActionResult> Update(int id, [FromBody] PostUpdateDto dto, [FromQuery] string? commitMessage = null)
        {
            var post = await _db.Posts.FindAsync(id);
            if (post == null) return NotFound();

            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role == "Manager")
            {
                var manager = await _db.Managers
                    .Include(m => m.User) // ✅ ensure User is loaded
                    .FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == post.DeptId);
                if (manager == null) return Forbid();

                if (!string.IsNullOrEmpty(commitMessage))
                {
                    _db.Commits.Add(new Commit
                    {
                        PostId = post.PostId,
                        ManagerId = manager.ManagerId,
                        Message = commitMessage,
                        CreatedAt = DateTime.UtcNow
                    });

                    // ✅ only notify if UserId is not null
                    if (post.UserId != null)
                    {
                        await _hub.Clients.User(post.UserId.ToString()!)
                            .SendAsync("ReceiveNotification", new
                            {
                                Type = "PostUpdate",
                                PostId = post.PostId,
                                CommitMessage = commitMessage,
                                Manager = manager.User.FullName,
                                Timestamp = DateTime.UtcNow
                            });
                    }
                }
            }
            else if (post.UserId != userId)
            {
                return Forbid(); // users can only update their own posts
            }

            // Apply updates
            if (!string.IsNullOrEmpty(dto.Title))
                post.Title = dto.Title;
            if (!string.IsNullOrEmpty(dto.Body))
                post.Body = dto.Body;

            post.UpdatedAt = DateTime.UtcNow;

            await _postService.UpdatePostAsync(post);
            await _db.SaveChangesAsync();

            return Ok(new { message = "Post updated successfully" });
        }

        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id, [FromQuery] string? commitMessage = null)
        {
            var post = await _db.Posts.FindAsync(id);
            if (post == null) return NotFound();

            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role != "Manager" && post.UserId != userId)
            {
                return Forbid("Only managers can delete the posts");
            }

            if (role == "Manager")
            {
                var manager = await _db.Managers
                    .Include(m => m.User) // ✅ ensure User is loaded
                    .FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == post.DeptId);
                if (manager == null) return Forbid();

                if (!string.IsNullOrEmpty(commitMessage))
                {
                    _db.Commits.Add(new Commit
                    {
                        PostId = post.PostId,
                        ManagerId = manager.ManagerId,
                        Message = commitMessage,
                        CreatedAt = DateTime.UtcNow
                    });

                    if (post.UserId != null)
                    {
                        await _hub.Clients.User(post.UserId.ToString()!)
                            .SendAsync("ReceiveNotification", new
                            {
                                Type = "PostDeletion",
                                PostId = post.PostId,
                                CommitMessage = commitMessage,
                                Manager = manager.User.FullName,
                                Timestamp = DateTime.UtcNow
                            });
                    }
                }

                await _postService.DeletePostAsync(post);
                await _db.SaveChangesAsync();
                return NoContent();
            }
            else if (post.UserId == userId)
            {
                await _postService.DeletePostAsync(post);
                await _db.SaveChangesAsync();
                return NoContent();
            }

            return Forbid();
        }

        [Authorize]
        [HttpPost("{id}/repost")]
        public async Task<IActionResult> Repost(int id)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            await _postService.RepostAsync(id, userId);
            return Ok();
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\TagsController.cs
﻿using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;
using System.Security.Claims;
using System.Threading.Tasks;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TagsController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public TagsController(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        [HttpGet]
        public async Task<IActionResult> Get([FromQuery] int? deptId)
        {
            var query = _db.Tags.AsQueryable();
            if (deptId.HasValue)
                query = query.Where(t => t.DeptId == deptId.Value);

            var tags = await query
                .ProjectTo<TagDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
            return Ok(tags);
        }

        // ✅ Create or get existing tag for logged-in user's dept
        [Authorize]

        [HttpPost]

        public async Task<IActionResult> Create([FromBody] TagCreateDto dto)

        {

            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            var user = await _db.Users

                .FirstOrDefaultAsync(u => u.UserId == userId);

            if (user == null)

                return Unauthorized(new { message = "User not found" });

            int deptId = user.DepartmentId;

            var existingTag = await _db.Tags

                .FirstOrDefaultAsync(t => t.TagName.ToLower() == dto.TagName.ToLower()

                                          && t.DeptId == deptId);

            if (existingTag != null)

            {

                var tagDto = _mapper.Map<TagDto>(existingTag);

                return Ok(tagDto);

            }

            var tag = new Tag

            {

                TagName = dto.TagName.Trim(),

                DeptId = deptId

            };

            _db.Tags.Add(tag);

            await _db.SaveChangesAsync();

            var createdDto = _mapper.Map<TagDto>(tag);

            return CreatedAtAction(nameof(Get), new { deptId = deptId }, createdDto);

        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\UsersController.cs
﻿using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;
using Project_Version1.Services;
using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class UsersController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;
        private readonly AuthService _authService;

        public UsersController(FnfKnowledgeBaseContext db, IMapper mapper, AuthService authService)
        {
            _db = db;
            _mapper = mapper;
            _authService = authService;
        }

        [HttpGet]
        public async Task<ActionResult<List<UserDto>>> GetAll()
        {
            var users = await _db.Users
                .ProjectTo<UserDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
            return Ok(users);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<UserDto>> Get(int id)
        {
            var user = await _db.Users.FindAsync(id);
            if (user == null) return NotFound();

            var userDto = _mapper.Map<UserDto>(user);
            return Ok(userDto);
        }

        [HttpGet("me")]
        [Authorize]
        public async Task<IActionResult> GetProfile()
        {
            // Use ClaimTypes.NameIdentifier (this is what JwtHelper sets)
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
            if (userIdClaim == null) return Unauthorized("User ID not found in token");

            if (!int.TryParse(userIdClaim.Value, out var userId)) return Unauthorized("Invalid user id in token");

            var user = await _db.Users.FindAsync(userId);
            if (user == null) return NotFound();

            var dto = _mapper.Map<UserDto>(user);
            return Ok(dto);
        }

        [Authorize]
        [HttpPut("update-profile")]
        public async Task<IActionResult> UpdateProfile([FromForm] UserUpdateDto dto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);

            if (userIdClaim == null) return Unauthorized("User ID not found in token");

            if (!int.TryParse(userIdClaim.Value, out var userId)) return Unauthorized("Invalid user id in token");

            var updatedUser = await _authService.UpdateProfileAsync(userId, dto);

            if (updatedUser == null) return NotFound("User not found");

            return Ok(updatedUser);
        }
        [HttpGet("me/stats")]
        [Authorize]
        public async Task<IActionResult> GetMyStats()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
            if (userIdClaim == null) return Unauthorized("User ID not found in token");

            if (!int.TryParse(userIdClaim.Value, out var userId))
                return Unauthorized("Invalid user id in token");

            var stats = await _authService.GetUserStatsAsync(userId);
            if (stats == null) return NotFound("User not found");

            return Ok(stats);
        }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Controllers\VotesController.cs
﻿using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class VotesController : ControllerBase
    {
        private readonly VoteService _voteService;

        public VotesController(VoteService voteService) => _voteService = voteService;

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Vote([FromBody] VoteDto dto)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            var ok = await _voteService.VoteAsync(dto, userId);
            if (!ok) return BadRequest(new { message = "Invalid vote request" });
            return Ok(new { message = "Vote processed successfully" });
        }

        // Get vote counts for a specific comment
        [HttpGet("comment/{commentId}/counts")]
        public async Task<IActionResult> GetCommentVoteCounts(int commentId)
        {
            try
            {
                var (upvotes, downvotes) = await _voteService.GetCommentVoteCountsAsync(commentId);
                return Ok(new { upvotes, downvotes });
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        // Get user's vote on a comment (requires auth)
        [Authorize]
        [HttpGet("comment/{commentId}/user-vote")]
        public async Task<IActionResult> GetUserVoteOnComment(int commentId)
        {
            try
            {
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
                var userVote = await _voteService.GetUserVoteOnCommentAsync(commentId, userId);
                return Ok(new { vote = userVote });
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        // Convenience endpoint for comment upvote
        [Authorize]
        [HttpPost("comment/{commentId}/upvote")]
        public async Task<IActionResult> UpvoteComment(int commentId)
        {
            try
            {
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
                var dto = new VoteDto { CommentId = commentId, VoteType = "upvote" };
                var ok = await _voteService.VoteAsync(dto, userId);

                if (!ok) return BadRequest(new { message = "Failed to process upvote" });

                // Return updated vote counts
                var (upvotes, downvotes) = await _voteService.GetCommentVoteCountsAsync(commentId);
                return Ok(new { upvotes, downvotes, userVote = "upvote" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        // Convenience endpoint for comment downvote
        [Authorize]
        [HttpPost("comment/{commentId}/downvote")]
        public async Task<IActionResult> DownvoteComment(int commentId)
        {
            try
            {
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
                var dto = new VoteDto { CommentId = commentId, VoteType = "downvote" };
                var ok = await _voteService.VoteAsync(dto, userId);

                if (!ok) return BadRequest(new { message = "Failed to process downvote" });

                // Return updated vote counts
                var (upvotes, downvotes) = await _voteService.GetCommentVoteCountsAsync(commentId);
                return Ok(new { upvotes, downvotes, userVote = "downvote" });
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Attachment.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Attachment
{
    public int AttachmentId { get; set; }

    public int? PostId { get; set; }

    public int? CommentId { get; set; }

    public string FileName { get; set; } = null!;

    public string FilePath { get; set; } = null!;

    public string FileType { get; set; } 

    public DateTime UploadedAt { get; set; }

    public virtual Comment? Comment { get; set; }

    public virtual Post? Post { get; set; }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Comment.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Comment
{
    public int CommentId { get; set; }

    public int? PostId { get; set; }

    public int UserId { get; set; }

    public int? ParentCommentId { get; set; }

    public string CommentText { get; set; } = null!;

    public DateTime CreatedAt { get; set; }

    public DateTime? UpdatedAt { get; set; }

    public virtual ICollection<Attachment> Attachments { get; set; } = new List<Attachment>();

    public virtual ICollection<Comment> InverseParentComment { get; set; } = new List<Comment>();

    public virtual Comment? ParentComment { get; set; }

    public virtual Post Post { get; set; } = null!;

    public virtual User User { get; set; } = null!;

    public virtual ICollection<Vote> Votes { get; set; } = new List<Vote>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Commit.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Commit
{
    public int CommitId { get; set; }

    public int? PostId { get; set; }

    public int ManagerId { get; set; }

    public string Message { get; set; } = null!;

    public DateTime CreatedAt { get; set; }

    public virtual Manager Manager { get; set; } = null!;

    public virtual Post Post { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Department.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Department
{
    public int DeptId { get; set; }

    public string DeptName { get; set; } = null!;

    public virtual ICollection<Manager> Managers { get; set; } = new List<Manager>();

    public virtual ICollection<Post> Posts { get; set; } = new List<Post>();

    public virtual ICollection<Tag> Tags { get; set; } = new List<Tag>();

    public virtual ICollection<User> Users { get; set; } = new List<User>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\FnfKnowledgeBaseContext.cs
﻿using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;

namespace Project_Version1.Data;

public partial class FnfKnowledgeBaseContext : DbContext
{
    public FnfKnowledgeBaseContext()
    {
    }

    public FnfKnowledgeBaseContext(DbContextOptions<FnfKnowledgeBaseContext> options)
        : base(options)
    {
    }

    public virtual DbSet<Attachment> Attachments { get; set; }

    public virtual DbSet<Comment> Comments { get; set; }

    public virtual DbSet<Commit> Commits { get; set; }

    public virtual DbSet<Department> Departments { get; set; }

    public virtual DbSet<Manager> Managers { get; set; }

    public virtual DbSet<Post> Posts { get; set; }

    public virtual DbSet<PostTag> PostTags { get; set; }

    public virtual DbSet<Repost> Reposts { get; set; }

    public virtual DbSet<Tag> Tags { get; set; }

    public virtual DbSet<User> Users { get; set; }

    public virtual DbSet<Vote> Votes { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
#warning To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see https://go.microsoft.com/fwlink/?LinkId=723263.
        => optionsBuilder.UseSqlServer("Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=FNF_KnowledgeBase;Integrated Security=True;Encrypt=False");

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Attachment>(entity =>
        {
            entity.HasKey(e => e.AttachmentId).HasName("PK__Attachme__442C64BEA7A7576E");

            entity.Property(e => e.FileName).HasMaxLength(200);
            entity.Property(e => e.FilePath).HasMaxLength(500);
            entity.Property(e => e.FileType).HasMaxLength(20);
            entity.Property(e => e.UploadedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");

            entity.HasOne(d => d.Comment).WithMany(p => p.Attachments)
                .HasForeignKey(d => d.CommentId)
                .HasConstraintName("FK__Attachmen__Comme__5070F446");

            entity.HasOne(d => d.Post).WithMany(p => p.Attachments)
                .HasForeignKey(d => d.PostId)
                .HasConstraintName("FK__Attachmen__PostI__4F7CD00D");
        });

        modelBuilder.Entity<Comment>(entity =>
        {
            entity.HasKey(e => e.CommentId).HasName("PK__Comments__C3B4DFCA01D3F462");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.UpdatedAt).HasColumnType("datetime");

            entity.HasOne(d => d.ParentComment).WithMany(p => p.InverseParentComment)
                .HasForeignKey(d => d.ParentCommentId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("FK__Comments__Parent__3F466844");

            entity.HasOne(d => d.Post).WithMany(p => p.Comments)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("FK__Comments__PostId__3D5E1FD2");

            entity.HasOne(d => d.User).WithMany(p => p.Comments)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("FK__Comments__UserId__3E52440B");
        });

        modelBuilder.Entity<Commit>(entity =>
        {
            entity.HasKey(e => e.CommitId).HasName("PK__Commits__73748B724CFAE850");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");

            entity.HasOne(d => d.Manager).WithMany(p => p.Commits)
                .HasForeignKey(d => d.ManagerId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Commits__Manager__59FA5E80");

            entity.HasOne(d => d.Post).WithMany(p => p.Commits)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Commits__PostId__59063A47");
        });

        modelBuilder.Entity<Department>(entity =>
        {
            entity.HasKey(e => e.DeptId).HasName("PK__Departme__014881AEFE7D8A9E");

            entity.HasIndex(e => e.DeptName, "UQ__Departme__5E5082657BEFDBB4").IsUnique();

            entity.Property(e => e.DeptName).HasMaxLength(200);
        });

        modelBuilder.Entity<Manager>(entity =>
        {
            entity.HasKey(e => e.ManagerId).HasName("PK__Managers__3BA2AAE14CC2F4A3");

            entity.HasIndex(e => e.UserId, "UQ__Managers__1788CC4DE8C2BF2C").IsUnique();

            entity.HasOne(d => d.Dept).WithMany(p => p.Managers)
                .HasForeignKey(d => d.DeptId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Managers__DeptId__4AB81AF0");

            entity.HasOne(d => d.User).WithOne(p => p.Manager)
                .HasForeignKey<Manager>(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Managers__UserId__49C3F6B7");
        });

        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.PostId).HasName("PK__Posts__AA126018472F972E");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.Title).HasMaxLength(500);
            entity.Property(e => e.UpdatedAt).HasColumnType("datetime");

            entity.HasOne(d => d.Dept).WithMany(p => p.Posts)
                .HasForeignKey(d => d.DeptId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Posts__DeptId__35BCFE0A");

            entity.HasOne(d => d.User).WithMany(p => p.Posts)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Posts__UserId__34C8D9D1");
        });

        modelBuilder.Entity<PostTag>(entity =>
        {
            entity.HasKey(e => e.PostTagId).HasName("PK__PostTags__325724FD3E737958");

            entity.HasOne(d => d.Post).WithMany(p => p.PostTags)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__PostTags__PostId__38996AB5");

            entity.HasOne(d => d.Tag).WithMany(p => p.PostTags)
                .HasForeignKey(d => d.TagId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__PostTags__TagId__398D8EEE");
        });

        modelBuilder.Entity<Repost>(entity =>
        {
            entity.HasKey(e => e.RepostId).HasName("PK__Reposts__5E7F921EDF28218B");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");

            entity.HasOne(d => d.Post).WithMany(p => p.Reposts)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Reposts__PostId__5441852A");

            entity.HasOne(d => d.User).WithMany(p => p.Reposts)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Reposts__UserId__5535A963");
        });

        modelBuilder.Entity<Tag>(entity =>
        {
            entity.HasKey(e => e.TagId).HasName("PK__Tags__657CF9ACE13ACE18");

            entity.HasIndex(e => e.TagName, "UQ__Tags__BDE0FD1D27F47ECD").IsUnique();

            entity.Property(e => e.TagName).HasMaxLength(200);

            entity.HasOne(d => d.Dept).WithMany(p => p.Tags)
                .HasForeignKey(d => d.DeptId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Tags__DeptId__2E1BDC42");
        });

        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.UserId).HasName("PK__Users__1788CC4CFDF19873");

            entity.HasIndex(e => e.Email, "UQ__Users__A9D10534FBED8653").IsUnique();

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.Email).HasMaxLength(200);
            entity.Property(e => e.FullName).HasMaxLength(200);
            entity.Property(e => e.PasswordHash).HasMaxLength(500);
            entity.Property(e => e.ProfilePicture).HasMaxLength(500);
            entity.Property(e => e.Role).HasMaxLength(20);

            entity.HasOne(d => d.Department).WithMany(p => p.Users)
                .HasForeignKey(d => d.DepartmentId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Users__Departmen__2A4B4B5E");
        });

        modelBuilder.Entity<Vote>(entity =>
        {
            entity.HasKey(e => e.VoteId).HasName("PK__Votes__52F015C2FC0ED114");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.VoteType).HasMaxLength(20);

            entity.HasOne(d => d.Comment).WithMany(p => p.Votes)
                .HasForeignKey(d => d.CommentId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("FK__Votes__CommentId__44FF419A");

            entity.HasOne(d => d.Post).WithMany(p => p.Votes)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("FK__Votes__PostId__440B1D61");

            entity.HasOne(d => d.User).WithMany(p => p.Votes)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.Cascade)
                .HasConstraintName("FK__Votes__UserId__45F365D3");
        });

        OnModelCreatingPartial(modelBuilder);
    }

    partial void OnModelCreatingPartial(ModelBuilder modelBuilder);
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Manager.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Manager
{
    public int ManagerId { get; set; }

    public int UserId { get; set; }

    public int DeptId { get; set; }

    public virtual ICollection<Commit> Commits { get; set; } = new List<Commit>();

    public virtual Department Dept { get; set; } = null!;

    public virtual User User { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Post.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Post
{
    public int PostId { get; set; }

    public int UserId { get; set; }

    public int DeptId { get; set; }

    public string Title { get; set; } = null!;

    public string Body { get; set; } = null!;

    public int? UpvoteCount { get; set; }

    public int? DownvoteCount { get; set; }

    public DateTime CreatedAt { get; set; }

    public DateTime? UpdatedAt { get; set; }

    public bool IsRepost { get; set; }

    public virtual ICollection<Attachment> Attachments { get; set; } = new List<Attachment>();

    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();

    public virtual ICollection<Commit> Commits { get; set; } = new List<Commit>();

    public virtual Department Dept { get; set; } = null!;

    public virtual ICollection<PostTag> PostTags { get; set; } = new List<PostTag>();

    public virtual ICollection<Repost> Reposts { get; set; } = new List<Repost>();

    public virtual User User { get; set; } = null!;

    public virtual ICollection<Vote> Votes { get; set; } = new List<Vote>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\PostTag.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class PostTag
{
    public int PostTagId { get; set; }

    public int PostId { get; set; }

    public int TagId { get; set; }

    public virtual Post Post { get; set; } = null!;

    public virtual Tag Tag { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Repost.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Repost
{
    public int RepostId { get; set; }

    public int PostId { get; set; }

    public int UserId { get; set; }

    public DateTime CreatedAt { get; set; }

    public virtual Post Post { get; set; } = null!;

    public virtual User User { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Tag.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Tag
{
    public int TagId { get; set; }

    public string TagName { get; set; } = null!;

    public int DeptId { get; set; }

    public virtual Department Dept { get; set; } = null!;

    public virtual ICollection<PostTag> PostTags { get; set; } = new List<PostTag>();
}
public class TagCreateDto
{
    public string TagName { get; set; } = string.Empty;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\User.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class User
{
    public int UserId { get; set; }

    public string FullName { get; set; } = null!;

    public string Email { get; set; } = null!;

    public string PasswordHash { get; set; } = null!;

    public string Role { get; set; } = null!;

    public string? ProfilePicture { get; set; }

    public int DepartmentId { get; set; }

    public DateTime CreatedAt { get; set; }

    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();

    public virtual Department Department { get; set; } = null!;

    public virtual Manager? Manager { get; set; }

    public virtual ICollection<Post> Posts { get; set; } = new List<Post>();

    public virtual ICollection<Repost> Reposts { get; set; } = new List<Repost>();

    public virtual ICollection<Vote> Votes { get; set; } = new List<Vote>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Data\Vote.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Vote
{
    public int? VoteId { get; set; }

    public int? PostId { get; set; }

    public int? CommentId { get; set; }

    public int UserId { get; set; }

    public string VoteType { get; set; } = null!;

    public DateTime CreatedAt { get; set; }

    public virtual Comment? Comment { get; set; }

    public virtual Post? Post { get; set; }

    public virtual User User { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\AuthDtos.cs
﻿
namespace Project_Version1.DTOs
{
    public class RegisterDto
    {
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string Role { get; set; } = "Employee";
        public int? DepartmentId { get; set; }
        public IFormFile? ProfilePicture { get; set; } // ✅

    }

    public class LoginDto
    {
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
    }

    public class AuthResponseDto
    {
        public string Token { get; set; } = null!;
        public int UserId { get; set; }
        public string Role { get; set; } = null!;
        public string? ProfilePicture { get; set; } // ✅ return stored path
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\CommentDtos.cs
﻿// DTOs/CommentDtos.cs - Updated with vote information
using System;

namespace Project_Version1.DTOs
{
    public class CommentCreateDto
    {
        public int? PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
    }
    public class CommentUpdateDto
    {
        public string CommentText { get; set; } = null!;
    }

    public class CommentDto
    {
        public int CommentId { get; set; }
        public int? PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
        public string? AuthorName { get; set; }
        public DateTime CreatedAt { get; set; }

        // Vote information
        public int UpvoteCount { get; set; }
        public int DownvoteCount { get; set; }
        public string? UserVote { get; set; } // "upvote", "downvote", or null
    }

    public class CommentWithRepliesDto
    {
        public int CommentId { get; set; }
        public int? PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
        public string? AuthorName { get; set; }
        public DateTime CreatedAt { get; set; }
        public List<CommentWithRepliesDto> Replies { get; set; } = new List<CommentWithRepliesDto>();

        // Vote information
        public int UpvoteCount { get; set; }
        public int DownvoteCount { get; set; }
        public string? UserVote { get; set; } // "upvote", "downvote", or null
    }

    // Enhanced comment DTO with additional info
    public class CommentDetailDto : CommentDto
    {
        public bool IsDeleted { get; set; }
        public DateTime? UpdatedAt { get; set; }
        public int ReplyCount { get; set; }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\DepartmentDto.cs
﻿namespace Project_Version1.DTOs
{
    public class DepartmentDto
    {
        public int DeptId { get; set; }
        public string DeptName { get; set; } = null!;
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\PostDtos.cs
﻿using Microsoft.AspNetCore.Http;
using System.Collections.Generic;

namespace Project_Version1.DTOs
{
    public class PostCreateDto
    {
        public int DeptId { get; set; }
        public string Title { get; set; } 
        public string Body { get; set; }
        public List<string>? Tags { get; set; }

        // ✅ New: Attachments (multiple files allowed)
        public List<IFormFile>? Attachments { get; set; }
    }

    public class PostUpdateDto
    {
        public string? Title { get; set; }
        public string? Body { get; set; }
        public List<string>? Tags { get; set; }
        public List<IFormFile>? Attachments { get; set; } // New files to add
    }

    public class PostBriefDto
    {
        public int PostId { get; set; }
        public string Title { get; set; } = null!;
        public string BodyPreview { get; set; } = null!;
        public int? UpvoteCount { get; set; }
        public int DownvoteCount { get; set; }
        public int CommentsCount { get; set; }
        public DateTime CreatedAt { get; set; }
        public string? AuthorName { get; set; }
        public bool IsRepost { get; set; }
        public string? RepostedBy { get; set; }
        }
    public class PostDetailDto
    {
        public int PostId { get; set; }
        public string Title { get; set; } = null!;
        public string Body { get; set; } = null!;  // Full body, not preview
        public int? UpvoteCount { get; set; }
        public int DownvoteCount { get; set; }
        public int CommentsCount { get; set; }
        public DateTime CreatedAt { get; set; }
        public string? AuthorName { get; set; }
        public string? DepartmentName { get; set; }
        public List<string>? Tags { get; set; }
        public List<AttachmentDto>? Attachments { get; set; }
        public bool IsRepost { get; set; }
        public string? RepostedBy { get; set; }
    }

    public class AttachmentDto
    {
        public int AttachmentId { get; set; }
        public string FileName { get; set; } = null!;
        public string FilePath { get; set; } = null!;
        public string FileType { get; set; } = null!;
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\TagDto.cs
﻿namespace Project_Version1.DTOs
{
    public class TagDto
    {
        public int TagId { get; set; }
        public string TagName { get; set; } = null!;
        public int DeptId { get; set; }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\UserDtos.cs
﻿namespace Project_Version1.DTOs
{
    public class UserDto
    {
        public int UserId { get; set; }
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Role { get; set; } = null!;
        public int? DepartmentId { get; set; }
        public string? ProfilePicture { get; set; } 
    }

    public class UserCreateDto
    {
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string Role { get; set; } = "Employee";
        public int? DepartmentId { get; set; }
        public IFormFile? ProfilePicture { get; set; }
    }

    public class UserUpdateDto
    {
        public string? FullName { get; set; }
        public string? Email { get; set; } = null!;
        public string? Password { get; set; } = null!;
        public int? DepartmentId { get; set; }
        public IFormFile? ProfilePicture { get; set; } // optional new upload
        public bool? RemoveProfilePicture { get; set; } // NEW - if true, remove existing file

    }
    public class UserStatsDto
    {
        public int TotalPosts { get; set; }
        public int TotalUpvotes { get; set; }
        public int TotalDownvotes { get; set; }
        public int TotalCommentsReceived { get; set; }
        public int TotalCommitsMade { get; set; }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\DTOs\VoteDtos.cs
﻿
namespace Project_Version1.DTOs
{
    public class VoteDto
    {
        public int? PostId { get; set; }
        public int? CommentId { get; set; }
        public string VoteType { get; set; } // "Upvote" or "Downvote"
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Helpers\JwtHelper.cs
﻿using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using Project_Version1.Data;

namespace Project_Version1.Helpers
{
    public class JwtHelper
    {
        private readonly IConfiguration _config;
        public JwtHelper(IConfiguration config) => _config = config;

        public string GenerateToken(User user)
        {
            var jwt = _config.GetSection("Jwt");

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwt["Key"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            // Fix for CS0023: Remove null-conditional operator from int property
            // Fix for CS1503: Ensure correct argument types for Claim constructor

            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, user.UserId.ToString()),
                new Claim(ClaimTypes.Name, user.FullName ?? string.Empty),
                new Claim(ClaimTypes.Email, user.Email ?? string.Empty),
                new Claim(ClaimTypes.Role, user.Role ?? "Employee"),
                new Claim("DeptId", user.DepartmentId.ToString()) // Fixed: int does not need null check
            };

            var token = new JwtSecurityToken(
                issuer: jwt["Issuer"],
                audience: jwt["Audience"],
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(jwt["ExpireMinutes"] ?? "100")),
                signingCredentials: creds
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Helpers\PaginationHelper.cs
﻿
using System;
using System.Linq;

namespace Project_Version1.Helpers
{
    public static class PaginationHelper
    {
        public static IQueryable<T> Paginate<T>(IQueryable<T> query, int page, int pageSize)
        {
            if (page < 1) page = 1;
            if (pageSize < 1) pageSize = 20;
            return query.Skip((page - 1) * pageSize).Take(pageSize);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Helpers\PasswordHasher.cs
﻿
using System;
using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using System.Security.Cryptography;

namespace Project_Version1.Helpers
{
    public static class PasswordHasher
    {
        // Produces salted hash: salt.hash
        public static string Hash(string password)
        {
            byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
            string saltStr = Convert.ToBase64String(salt);
            var hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: password,
                salt: salt,
                prf: KeyDerivationPrf.HMACSHA256,
                iterationCount: 100_000,
                numBytesRequested: 256 / 8));

            return $"{saltStr}.{hashed}";
        }

        public static bool Verify(string password, string stored)
        {
            if (string.IsNullOrWhiteSpace(stored)) return false;
            var parts = stored.Split('.');
            if (parts.Length != 2) return false;
            var salt = Convert.FromBase64String(parts[0]);
            var expected = parts[1];

            var hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: password,
                salt: salt,
                prf: KeyDerivationPrf.HMACSHA256,
                iterationCount: 100_000,
                numBytesRequested: 256 / 8));

            return hashed == expected;
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Hubs\NotificationHub.cs
﻿
using Microsoft.AspNetCore.SignalR;

namespace Project_Version1.Hubs
{
    public class NotificationHub:Hub
    {
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Profiles\MappingProfile.cs
﻿// Profiles/MappingProfile.cs - Updated comment mappings
using AutoMapper;
using Project_Version1.Data;
using Project_Version1.DTOs;
using System.Linq;

namespace Project_Version1.Profiles
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            // User mappings (unchanged)
            CreateMap<User, UserDto>()
                .ForMember(dest => dest.Role, opt => opt.MapFrom(src => src.Role ?? "Employee"))
                .ForMember(dest => dest.ProfilePicture, opt => opt.MapFrom(src => src.ProfilePicture));

            CreateMap<UserCreateDto, User>()
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());

            CreateMap<UserUpdateDto, User>()
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.ProfilePicture, opt => opt.Ignore())
                .ForMember(dest => dest.Email, opt => opt.Ignore())
                .ForAllMembers(opts => opts.Condition((src, dest, srcMember) => srcMember != null));

            CreateMap<RegisterDto, User>()
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());

            // Post mappings (unchanged)
            CreateMap<PostCreateDto, Post>()
                .ForMember(dest => dest.PostId, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpvoteCount, opt => opt.MapFrom(src => 0))
                .ForMember(dest => dest.DownvoteCount, opt => opt.MapFrom(src => 0))
                .ForMember(dest => dest.IsRepost, opt => opt.MapFrom(src => false))
                .ForMember(dest => dest.Attachments, opt => opt.Ignore())
                .ForMember(dest => dest.PostTags, opt => opt.Ignore());

            CreateMap<Post, PostBriefDto>()
                .ForMember(dest => dest.BodyPreview, opt => opt.MapFrom(src =>
                    string.IsNullOrEmpty(src.Body) ? string.Empty :
                    src.Body.Length > 200 ? src.Body.Substring(0, 200) + "..." : src.Body))
                .ForMember(dest => dest.UpvoteCount, opt => opt.MapFrom(src => src.UpvoteCount ?? 0))
                .ForMember(dest => dest.DownvoteCount, opt => opt.MapFrom(src => src.DownvoteCount ?? 0))
                .ForMember(dest => dest.CommentsCount, opt => opt.MapFrom(src =>
                    src.Comments != null ? src.Comments.Count : 0))
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.IsRepost, opt => opt.MapFrom(src => src.IsRepost))
                .ForMember(dest => dest.RepostedBy, opt => opt.MapFrom(src =>
                    src.Reposts.OrderByDescending(r => r.CreatedAt).FirstOrDefault().User.FullName));

            // Comment mappings - Updated to ignore vote fields (handled in service)
            CreateMap<CommentCreateDto, Comment>()
                .ForMember(dest => dest.CommentId, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore());

            CreateMap<Comment, CommentDto>()
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.UpvoteCount, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.DownvoteCount, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.UserVote, opt => opt.Ignore()); // Set in service

            CreateMap<Comment, CommentWithRepliesDto>()
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.Replies, opt => opt.Ignore()) // Built manually in service
                .ForMember(dest => dest.UpvoteCount, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.DownvoteCount, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.UserVote, opt => opt.Ignore()); // Set in service

            CreateMap<Comment, CommentDetailDto>()
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.IsDeleted, opt => opt.MapFrom(src => src.CommentText == "[Comment deleted]"))
                .ForMember(dest => dest.ReplyCount, opt => opt.MapFrom(src =>
                    src.InverseParentComment != null ? src.InverseParentComment.Count : 0))
                .ForMember(dest => dest.UpvoteCount, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.DownvoteCount, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.UserVote, opt => opt.Ignore()); // Set in service

            // Vote mappings (unchanged)
            CreateMap<VoteDto, Vote>()
                .ForMember(dest => dest.VoteId, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());

            // Tag and Department mappings (unchanged)
            CreateMap<Tag, TagDto>()
                .ForMember(dest => dest.TagId, opt => opt.MapFrom(src => src.TagId))
                .ForMember(dest => dest.TagName, opt => opt.MapFrom(src => src.TagName))
                .ForMember(dest => dest.DeptId, opt => opt.MapFrom(src => src.DeptId));

            CreateMap<Department, DepartmentDto>()
                .ForMember(dest => dest.DeptId, opt => opt.MapFrom(src => src.DeptId))
                .ForMember(dest => dest.DeptName, opt => opt.MapFrom(src => src.DeptName));

            CreateMap<Post, PostDetailDto>()
                .ForMember(dest => dest.Body, opt => opt.MapFrom(src => src.Body))  // Full body
                .ForMember(dest => dest.UpvoteCount, opt => opt.MapFrom(src => src.UpvoteCount ?? 0))
                .ForMember(dest => dest.DownvoteCount, opt => opt.MapFrom(src => src.DownvoteCount ?? 0))
                .ForMember(dest => dest.CommentsCount, opt => opt.MapFrom(src =>
                    src.Comments != null ? src.Comments.Count : 0))
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.DepartmentName, opt => opt.MapFrom(src => src.Dept.DeptName))
                .ForMember(dest => dest.Tags, opt => opt.MapFrom(src =>
                    src.PostTags.Select(pt => pt.Tag.TagName).ToList()))
                .ForMember(dest => dest.Attachments, opt => opt.MapFrom(src => src.Attachments))
                .ForMember(dest => dest.IsRepost, opt => opt.MapFrom(src => src.IsRepost))
                .ForMember(dest => dest.RepostedBy, opt => opt.MapFrom(src =>
                    src.Reposts.OrderByDescending(r => r.CreatedAt).FirstOrDefault().User.FullName));

            CreateMap<Attachment, AttachmentDto>();
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Services\AuthService.cs
﻿using System.Threading.Tasks;

using Microsoft.EntityFrameworkCore;

using AutoMapper;

using Project_Version1.Data;

using Project_Version1.DTOs;

using Project_Version1.Helpers;

namespace Project_Version1.Services

{

    public class AuthService

    {

        private readonly FnfKnowledgeBaseContext _db;

        private readonly JwtHelper _jwt;

        private readonly IMapper _mapper;

        private readonly IWebHostEnvironment _env;


        public AuthService(FnfKnowledgeBaseContext db, JwtHelper jwt, IMapper mapper, IWebHostEnvironment env)

        {

            _db = db;

            _jwt = jwt;

            _mapper = mapper;

            _env = env;

        }

        public interface IAuthService
        {
            Task<AuthResponseDto?> RegisterAsync(RegisterDto dto);
            Task<AuthResponseDto?> LoginAsync(LoginDto dto);
            Task<UserDto?> UpdateProfileAsync(int userId, UserUpdateDto dto);

        }

        public async Task<AuthResponseDto?> RegisterAsync(RegisterDto dto)

        {

            var exists = await _db.Users.AnyAsync(u => u.Email == dto.Email);

            if (exists) return null;

            var user = _mapper.Map<User>(dto);

            user.PasswordHash = PasswordHasher.Hash(dto.Password);

            user.CreatedAt = DateTime.UtcNow;

            // Handle profile picture upload

            if (dto.ProfilePicture != null && dto.ProfilePicture.Length > 0)

            {

                var uploadsFolder = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot/uploads/profile-pics");

                if (!Directory.Exists(uploadsFolder))

                    Directory.CreateDirectory(uploadsFolder);

                var fileName = $"{Guid.NewGuid()}{Path.GetExtension(dto.ProfilePicture.FileName)}";

                var filePath = Path.Combine(uploadsFolder, fileName);

                using (var stream = new FileStream(filePath, FileMode.Create))

                {

                    await dto.ProfilePicture.CopyToAsync(stream);

                }

                user.ProfilePicture = $"/uploads/profile-pics/{fileName}";

            }

            // Save user

            _db.Users.Add(user);

            await _db.SaveChangesAsync();

            if (user.Role == "Manager" && user.DepartmentId > 0)

            {

                var manager = new Manager

                {

                    UserId = user.UserId,

                    DeptId = user.DepartmentId

                };

                _db.Managers.Add(manager);

                await _db.SaveChangesAsync();

            }

            // Generate JWT

            var token = _jwt.GenerateToken(user);

            return new AuthResponseDto

            {

                Token = token,

                UserId = user.UserId,

                Role = user.Role ?? "Employee",

                ProfilePicture = user.ProfilePicture

            };

        }

        public async Task<AuthResponseDto?> LoginAsync(LoginDto dto)

        {

            var user = await _db.Users.FirstOrDefaultAsync(u => u.Email == dto.Email);

            if (user == null || !PasswordHasher.Verify(dto.Password, user.PasswordHash))

                return null;

            var token = _jwt.GenerateToken(user);

            return new AuthResponseDto

            {

                Token = token,

                UserId = user.UserId,

                Role = user.Role ?? "Employee",

                ProfilePicture = user.ProfilePicture

            };

        }

        //public async Task<UserDto?> UpdateProfileAsync(int userId, UserUpdateDto dto)

        //{

        //    var user = await _db.Users.FirstOrDefaultAsync(u => u.UserId == userId);

        //    if (user == null) return null;

        //    // Update basic fields

        //    if (!string.IsNullOrEmpty(dto.FullName))

        //        user.FullName = dto.FullName;

        //    if (dto.DepartmentId.HasValue)

        //        user.DepartmentId = dto.DepartmentId.Value;

        //    if (!string.IsNullOrEmpty(dto.Email))

        //        user.Email = dto.Email;

        //    if (!string.IsNullOrEmpty(dto.Password))

        //        user.PasswordHash = PasswordHasher.Hash(dto.Password);

        //    if (dto.ProfilePicture != null && dto.ProfilePicture.Length > 0)

        //    {

        //        var uploadsFolder = Path.Combine(_env.WebRootPath, "uploads/profile-pics");

        //        if (!Directory.Exists(uploadsFolder))

        //            Directory.CreateDirectory(uploadsFolder);

        //        var fileName = $"{Guid.NewGuid()}{Path.GetExtension(dto.ProfilePicture.FileName)}";

        //        var filePath = Path.Combine(uploadsFolder, fileName);

        //        using (var stream = new FileStream(filePath, FileMode.Create))

        //        {

        //            await dto.ProfilePicture.CopyToAsync(stream);

        //        }

        //        if (!string.IsNullOrEmpty(user.ProfilePicture))

        //        {

        //            var oldFile = Path.Combine(_env.WebRootPath, user.ProfilePicture.TrimStart('/'));

        //            if (File.Exists(oldFile))

        //                File.Delete(oldFile);

        //        }

        //        user.ProfilePicture = $"/uploads/profile-pics/{fileName}";

        //    }

        //    await _db.SaveChangesAsync();

        //    return _mapper.Map<UserDto>(user);

        //}
        public async Task<UserDto?> UpdateProfileAsync(int userId, UserUpdateDto dto)
        {
            var user = await _db.Users.FirstOrDefaultAsync(u => u.UserId == userId);
            if (user == null) return null;

            // ... existing updates ...

            // Handle new upload
            if (dto.ProfilePicture != null && dto.ProfilePicture.Length > 0)
            {
                var uploadsFolder = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot/uploads/profile-pics");
                if (!Directory.Exists(uploadsFolder)) Directory.CreateDirectory(uploadsFolder);
                if(!string.IsNullOrEmpty(dto.Password))
                {
                    user.PasswordHash = PasswordHasher.Hash(dto.Password);

                }
                // delete existing file if any
                if (!string.IsNullOrEmpty(user.ProfilePicture))
                {
                    var existingPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", user.ProfilePicture.TrimStart('/').Replace('/', Path.DirectorySeparatorChar));
                    if (System.IO.File.Exists(existingPath)) System.IO.File.Delete(existingPath);
                }

                var fileName = $"{Guid.NewGuid()}{Path.GetExtension(dto.ProfilePicture.FileName)}";
                var filePath = Path.Combine(uploadsFolder, fileName);
                using (var stream = new FileStream(filePath, FileMode.Create))
                {
                    await dto.ProfilePicture.CopyToAsync(stream);
                }
                user.ProfilePicture = $"/uploads/profile-pics/{fileName}";
            }

            // Handle explicit removal
            if (dto.RemoveProfilePicture == true)
            {
                if (!string.IsNullOrEmpty(user.ProfilePicture))
                {
                    var existingPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", user.ProfilePicture.TrimStart('/').Replace('/', Path.DirectorySeparatorChar));
                    if (System.IO.File.Exists(existingPath)) System.IO.File.Delete(existingPath);
                }
                user.ProfilePicture = null;
            }

            await _db.SaveChangesAsync();

            return _mapper.Map<UserDto>(user);
        }
        public async Task<UserStatsDto> GetUserStatsAsync(int userId)
        {
            var user = await _db.Users
                .Include(u => u.Posts)
                    .ThenInclude(p => p.Votes)
                .Include(u => u.Posts)
                    .ThenInclude(p => p.Comments)
                .Include(u => u.Manager)
                    .ThenInclude(m => m.Commits)
                .FirstOrDefaultAsync(u => u.UserId == userId);

            if (user == null)
                return null;

            var stats = new UserStatsDto
            {
                TotalPosts = user.Posts.Count,
                TotalUpvotes = user.Posts.Sum(p => p.Votes.Count(v => v.VoteType == "Upvote")),
                TotalDownvotes = user.Posts.Sum(p => p.Votes.Count(v => v.VoteType == "Downvote")),
                TotalCommentsReceived = user.Posts.Sum(p => p.Comments.Count),
                TotalCommitsMade = user.Manager?.Commits.Count ?? 0
            };

            return stats;
        }

    }

}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Services\CommentService.cs
﻿// Services/CommentService.cs - Updated with vote functionality
using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using AutoMapper.QueryableExtensions;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class CommentService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;
        private readonly VoteService _voteService;

        public CommentService(FnfKnowledgeBaseContext db, IMapper mapper, VoteService voteService)
        {
            _db = db;
            _mapper = mapper;
            _voteService = voteService;
        }

        public async Task<Comment?> AddCommentAsync(CommentCreateDto dto, int userId)
        {
            // Validate that the post exists
            var postExists = await _db.Posts.AnyAsync(p => p.PostId == dto.PostId);
            if (!postExists)
            {
                throw new ArgumentException($"Post with ID {dto.PostId} does not exist.");
            }

            // If this is a reply, validate that the parent comment exists and belongs to the same post
            if (dto.ParentCommentId.HasValue && dto.ParentCommentId.Value > 0)
            {
                var parentComment = await _db.Comments
                    .FirstOrDefaultAsync(c => c.CommentId == dto.ParentCommentId.Value);

                if (parentComment == null)
                {
                    throw new ArgumentException($"Parent comment with ID {dto.ParentCommentId.Value} does not exist.");
                }

                if (parentComment.PostId != dto.PostId)
                {
                    throw new ArgumentException("Parent comment must belong to the same post.");
                }
            }
            else
            {
                dto.ParentCommentId = null; // treat 0 as null
            }

            var comment = _mapper.Map<Comment>(dto);
            comment.UserId = userId;
            comment.CreatedAt = DateTime.UtcNow;

            _db.Comments.Add(comment);
            await _db.SaveChangesAsync();

            // Return the comment with user information
            return await _db.Comments
                .Include(c => c.User)
                .FirstOrDefaultAsync(c => c.CommentId == comment.CommentId);
        }

        public async Task<List<CommentDto>> GetCommentsForPostAsync(int postId, int? currentUserId = null)
        {
            var comments = await _db.Comments
                .Where(c => c.PostId == postId)
                .Include(c => c.User)
                .OrderBy(c => c.CreatedAt)
                .ToListAsync();

            var commentDtos = new List<CommentDto>();

            foreach (var comment in comments)
            {
                var dto = _mapper.Map<CommentDto>(comment);

                // Get vote counts
                var (upvotes, downvotes) = await _voteService.GetCommentVoteCountsAsync(comment.CommentId);
                dto.UpvoteCount = upvotes;
                dto.DownvoteCount = downvotes;

                // Get user's vote if user is logged in
                if (currentUserId.HasValue)
                {
                    dto.UserVote = await _voteService.GetUserVoteOnCommentAsync(comment.CommentId, currentUserId.Value);
                }

                commentDtos.Add(dto);
            }

            return commentDtos;
        }

        // Get hierarchical comments (nested structure) with vote information
        public async Task<List<CommentWithRepliesDto>> GetCommentsHierarchyAsync(int postId, int? currentUserId = null)
        {
            var allComments = await _db.Comments
                .Where(c => c.PostId == postId)
                .Include(c => c.User)
                .OrderBy(c => c.CreatedAt)
                .ToListAsync();

            // Build hierarchy with vote information
            var commentDtos = new List<CommentWithRepliesDto>();

            foreach (var comment in allComments)
            {
                var dto = _mapper.Map<CommentWithRepliesDto>(comment);

                // Get vote counts
                var (upvotes, downvotes) = await _voteService.GetCommentVoteCountsAsync(comment.CommentId);
                dto.UpvoteCount = upvotes;
                dto.DownvoteCount = downvotes;

                // Get user's vote if user is logged in
                if (currentUserId.HasValue)
                {
                    dto.UserVote = await _voteService.GetUserVoteOnCommentAsync(comment.CommentId, currentUserId.Value);
                }

                commentDtos.Add(dto);
            }

            var commentDict = commentDtos.ToDictionary(c => c.CommentId);
            var rootComments = new List<CommentWithRepliesDto>();

            foreach (var comment in commentDtos)
            {
                if (comment.ParentCommentId.HasValue && commentDict.ContainsKey(comment.ParentCommentId.Value))
                {
                    // This is a reply
                    commentDict[comment.ParentCommentId.Value].Replies.Add(comment);
                }
                else
                {
                    // This is a root comment
                    rootComments.Add(comment);
                }
            }

            return rootComments;
        }

        public async Task<Comment?> GetCommentAsync(int commentId)
        {
            return await _db.Comments
                .Include(c => c.User)
                .Include(c => c.Post)
                .FirstOrDefaultAsync(c => c.CommentId == commentId);
        }
        public async Task DeleteCommentAsync(Comment comment)
        {
            // Soft delete: just remove the comment if no replies
            var hasReplies = await _db.Comments.AnyAsync(c => c.ParentCommentId == comment.CommentId);
            if (hasReplies)
            {
                // If there are replies, we can choose to either prevent deletion or mark as deleted
                // Here, we'll just mark the comment as "[deleted]" and keep it
                comment.CommentText = "[deleted]";
                _db.Comments.Update(comment);
            }
            else
            {
                _db.Comments.Remove(comment);
            }

            _db.Comments.Remove(comment);
            await _db.SaveChangesAsync();
        }
        public async Task ForceDeleteCommentAsync(Comment comment)
        {
            // First delete all replies recursively
            await DeleteCommentAndRepliesRecursively(comment.CommentId);
            await _db.SaveChangesAsync();
        }

        private async Task DeleteCommentAndRepliesRecursively(int commentId)
        {
            var replies = await _db.Comments
                .Where(c => c.ParentCommentId == commentId)
                .ToListAsync();

            foreach (var reply in replies)
            {
                await DeleteCommentAndRepliesRecursively(reply.CommentId);
            }

            var comment = await _db.Comments.FindAsync(commentId);
            if (comment != null)
            {
                _db.Comments.Remove(comment);
            }
        }

        // Get comment with vote information
        public async Task<CommentDto?> GetCommentWithVotesAsync(int commentId, int? currentUserId = null)
        {
            var comment = await _db.Comments
                .Include(c => c.User)
                .FirstOrDefaultAsync(c => c.CommentId == commentId);

            if (comment == null) return null;

            var dto = _mapper.Map<CommentDto>(comment);

            // Get vote counts
            var (upvotes, downvotes) = await _voteService.GetCommentVoteCountsAsync(commentId);
            dto.UpvoteCount = upvotes;
            dto.DownvoteCount = downvotes;

            // Get user's vote if user is logged in
            if (currentUserId.HasValue)
            {
                dto.UserVote = await _voteService.GetUserVoteOnCommentAsync(commentId, currentUserId.Value);
            }

            return dto;
        }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Services\FileService.cs
﻿
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Project_Version1.Data;

namespace Project_Version1.Services
{
    public class FileService
    {
        private readonly IWebHostEnvironment _env;
        public FileService(IWebHostEnvironment env) => _env = env;

        public async Task<(string fileName, string filePath,string fileType)> SaveFileAsync(IFormFile file)
        {
            var rootPath = _env.WebRootPath;
            if (string.IsNullOrEmpty(rootPath))
            {
                rootPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot");
            }
            var uploads = Path.Combine(rootPath, "uploads","attachments");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            var fileName = $"{Guid.NewGuid()}_{Path.GetFileName(file.FileName)}";
            var filePath = Path.Combine(uploads, fileName);

            using (var fs = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(fs);
            }

            var relativePath = $"/uploads/attachments/{fileName}";
            var extension= Path.GetExtension(file.FileName).ToLower();
            string fileType= extension switch
            {
                ".jpg" or ".jpeg" or ".png" or ".gif" => "image",
                ".pdf" => "pdf",
                ".doc" or ".docx" => "word",
                ".xls" or ".xlsx" => "excel",
                ".ppt" or ".pptx" => "powerpoint",
                ".txt" => "text",
                _ => "other"
            };
            return (fileName, relativePath, fileType);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Services\NameIdentifierUserIdProvider.cs
﻿using Microsoft.AspNetCore.SignalR;
using System.Security.Claims;

namespace Project_Version1.Services
{
    public class NameIdentifierUserIdProvider: IUserIdProvider
    {
        public string? GetUserId(HubConnectionContext connection)
        {
            return connection.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Services\PostService.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using Project_Version1.Data;
using Project_Version1.DTOs;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;

namespace Project_Version1.Services
{
    public class PostService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;
        private readonly IWebHostEnvironment _env;
        private readonly FileService _fileService;

        public PostService(
            FnfKnowledgeBaseContext db,
            IMapper mapper,
            IWebHostEnvironment env,
            FileService fileService)
        {
            _db = db;
            _mapper = mapper;
            _env = env;
            _fileService = fileService;
        }

        public async Task<Post> CreatePostAsync(PostCreateDto dto, int userId, int deptId)
        {
            var post = _mapper.Map<Post>(dto);
            post.UserId = userId;
            post.DeptId = deptId;
            post.CreatedAt = DateTime.UtcNow;

            // Store body as raw Markdown (frontend will render with react-markdown)
            if (!string.IsNullOrWhiteSpace(dto.Body))
                post.Body = dto.Body;

            _db.Posts.Add(post);
            await _db.SaveChangesAsync();

            // Handle Tags
            if (dto.Tags != null && dto.Tags.Any())
            {
                foreach (var tagName in dto.Tags
                             .Select(t => t.Trim().ToLower())
                             .Distinct())
                {
                    var tag = await _db.Tags
                        .FirstOrDefaultAsync(x => x.TagName.ToLower() == tagName && x.DeptId == deptId);

                    if (tag == null)
                    {
                        tag = new Tag { TagName = tagName, DeptId = deptId };
                        _db.Tags.Add(tag);
                        //await _db.SaveChangesAsync();
                    }

                    _db.PostTags.Add(new PostTag { PostId = post.PostId, TagId = tag.TagId });
                }

                await _db.SaveChangesAsync();
            }

            // Handle Attachments
            if (dto.Attachments != null && dto.Attachments.Any())
            {
                foreach (var file in dto.Attachments)
                {
                    if (file.Length == 0) continue;

                    // optional validation (size/type)
                    if (file.Length > 5 * 1024 * 1024)
                        throw new InvalidOperationException("File too large (max 5MB).");

                    var (fileName, filePath, fileType) = await _fileService.SaveFileAsync(file);

                    var attachment = new Attachment
                    {
                        PostId = post.PostId,
                        FileName = file.FileName,
                        FilePath = filePath, 
                        FileType = fileType,
                        UploadedAt = DateTime.UtcNow
                    };

                    _db.Attachments.Add(attachment);
                }

                await _db.SaveChangesAsync();
            }

            return post;
        }

        public IQueryable<Post> QueryPosts() =>
            _db.Posts
                .Include(p => p.User)
                .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)
                .Include(p => p.Comments)
                .Include(p => p.Reposts).ThenInclude(r => r.User);

        public async Task<Post?> GetPostAsync(int id) =>
            await _db.Posts
                .Include(p => p.User)
                .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)
                .Include(p => p.Comments).ThenInclude(c => c.User)
                .Include(p => p.Attachments)
                .Include(p => p.Reposts).ThenInclude(r => r.User)
                .FirstOrDefaultAsync(p => p.PostId == id);

        public async Task<List<PostBriefDto>> GetPostsFeedAsync(int? deptId, string? tag, int page, int pageSize)
        {
            var query = _db.Posts.AsQueryable();

            if (deptId.HasValue)
                query = query.Where(p => p.DeptId == deptId.Value);

            if (!string.IsNullOrEmpty(tag))
                query = query.Where(p => p.PostTags.Any(pt => pt.Tag.TagName == tag));

            query = query.OrderByDescending(p => p.CreatedAt);

            var paged = query.Skip((page - 1) * pageSize).Take(pageSize);

            var posts = await paged
                .Include(p => p.User)
                .Include(p => p.Comments)
                .Include(p => p.Reposts).ThenInclude(r => r.User)
                .ToListAsync();

            return _mapper.Map<List<PostBriefDto>>(posts);
        }

        public async Task UpdatePostAsync(Post post)
        {
            post.UpdatedAt = DateTime.UtcNow;
            _db.Posts.Update(post);
            //await _db.SaveChangesAsync();
        }

        public async Task DeletePostAsync(Post post)
        {
            //remove votes associated with this post
            var votes = _db.Votes.Where(v => v.PostId == post.PostId);
            _db.Votes.RemoveRange(votes);
            // remove comments associated with this post
            var comments = _db.Comments.Where(c => c.PostId == post.PostId);
            _db.Comments.RemoveRange(comments);
            // remove reposts associated with this post
            var reposts = _db.Reposts.Where(r => r.PostId == post.PostId);
            _db.Reposts.RemoveRange(reposts);

            // remove tags mapping
            var tags = _db.PostTags.Where(pt => pt.PostId == post.PostId);
            _db.PostTags.RemoveRange(tags);

            // remove attachments
            var attachments = _db.Attachments.Where(a => a.PostId == post.PostId);
            _db.Attachments.RemoveRange(attachments);

            _db.Posts.Remove(post);
            await _db.SaveChangesAsync();
        }

        public async Task RepostAsync(int postId, int userId)
        {
            var exists = await _db.Reposts.AnyAsync(r => r.PostId == postId && r.UserId == userId);
            if (exists) return;

            var repost = new Repost
            {
                PostId = postId,
                UserId = userId,
                CreatedAt = DateTime.UtcNow
            };

            _db.Reposts.Add(repost);
            await _db.SaveChangesAsync();
        }
        public async Task<List<Post>> GetPostsByUserAsync(int userId)
        {
            return await _db.Posts
                .Where(p => p.UserId == userId)
                .Include(p => p.User)
                .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)
                .Include(p => p.Comments)
                .Include(p => p.Reposts).ThenInclude(r => r.User)
                .OrderByDescending(p => p.CreatedAt)
                .ToListAsync();
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF/Backend_v5\Services\VoteService.cs
﻿// Services/VoteService.cs - Updated to handle comment voting
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class VoteService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public VoteService(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        public async Task<bool> VoteAsync(VoteDto dto, int userId)
        {
            if (dto.PostId == null && dto.CommentId == null) return false;

            var existing = await _db.Votes.FirstOrDefaultAsync(v =>
                v.UserId == userId &&
                v.PostId == dto.PostId &&
                v.CommentId == dto.CommentId);

            if (existing != null)
            {
                if (existing.VoteType == dto.VoteType)
                {
                    // Remove vote if clicking same vote type
                    _db.Votes.Remove(existing);
                }
                else
                {
                    // Change vote type
                    existing.VoteType = dto.VoteType;
                    existing.CreatedAt = DateTime.UtcNow;
                    _db.Votes.Update(existing);
                }
            }
            else
            {
                var vote = _mapper.Map<Vote>(dto);
                vote.UserId = userId;
                vote.CreatedAt = DateTime.UtcNow;
                _db.Votes.Add(vote);
            }

            await _db.SaveChangesAsync();

            // Update counters for both posts and comments
            if (dto.PostId.HasValue)
                await UpdatePostVoteCountersAsync(dto.PostId.Value);

            if (dto.CommentId.HasValue)
                await UpdateCommentVoteCountersAsync(dto.CommentId.Value);

            return true;
        }

        private async Task UpdatePostVoteCountersAsync(int postId)
        {
            var upvotes = await _db.Votes.CountAsync(v => v.PostId == postId && v.VoteType == "upvote");
            var downvotes = await _db.Votes.CountAsync(v => v.PostId == postId && v.VoteType == "downvote");

            var post = await _db.Posts.FindAsync(postId);
            if (post != null)
            {
                post.UpvoteCount = upvotes;
                post.DownvoteCount = downvotes;
                _db.Posts.Update(post);
                await _db.SaveChangesAsync();
            }
        }

        private async Task UpdateCommentVoteCountersAsync(int commentId)
        {
            // Since Comment entity doesn't have vote count fields, 
            // we'll calculate them dynamically when needed
            // This method exists for consistency but doesn't update entity

            // If you want to cache counts, you could add them to a separate table
            // or calculate them in real-time in the service methods
        }

        // New method to get comment vote counts
        public async Task<(int upvotes, int downvotes)> GetCommentVoteCountsAsync(int commentId)
        {
            var upvotes = await _db.Votes.CountAsync(v => v.CommentId == commentId && v.VoteType == "upvote");
            var downvotes = await _db.Votes.CountAsync(v => v.CommentId == commentId && v.VoteType == "downvote");
            return (upvotes, downvotes);
        }

        // Get user's vote on a comment
        public async Task<string?> GetUserVoteOnCommentAsync(int commentId, int userId)
        {
            var vote = await _db.Votes.FirstOrDefaultAsync(v =>
                v.CommentId == commentId && v.UserId == userId);
            return vote?.VoteType;
        }
    }
}


