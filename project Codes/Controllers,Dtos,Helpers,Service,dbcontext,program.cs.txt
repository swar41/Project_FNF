

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Program.cs

using AutoMapper;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using Project_Version1.Data;
using Project_Version1.Helpers;

using Project_Version1.Services;
using System.Text;
using Project_Version1.Profiles;

var builder = WebApplication.CreateBuilder(args);

// DbContext
builder.Services.AddDbContext<FnfKnowledgeBaseContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("myCon")));
// AutoMapper
builder.Services.AddAutoMapper(cfg => { cfg.AddMaps(typeof(MappingProfile).Assembly); });
// Helpers & Services
builder.Services.AddScoped<JwtHelper>();
builder.Services.AddScoped<AuthService>();
builder.Services.AddScoped<PostService>();
builder.Services.AddScoped<CommentService>();
builder.Services.AddScoped<VoteService>();
builder.Services.AddScoped<NotificationService>();
builder.Services.AddScoped<FileService>();

// SignalR
builder.Services.AddSignalR();



// Controllers
builder.Services.AddControllers().AddJsonOptions(options =>{

        options.JsonSerializerOptions.ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.Preserve;
        options.JsonSerializerOptions.WriteIndented = true;
    });
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// JWT
var jwt = builder.Configuration.GetSection("Jwt");
builder.Services.AddAuthentication(options =>
{
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = jwt["Issuer"],
        ValidAudience = jwt["Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwt["Key"]))
    };
});
    
// Replace this line:
// builder.Services.AddAutoMapper(typeof(Program).Assembly);

// With this line:
builder.Services.AddAuthorization();
builder.Services.AddCors(o => o.AddPolicy("dev", p => p.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader()));

var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
var uploadsDir = Path.Combine(app.Environment.WebRootPath ??Path.Combine(Directory.GetCurrentDirectory(), "wwwroot"),"uploads","attachments");
app.UseCors("dev");
app.UseStaticFiles(); // enables serving from wwwroot

app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.MapHub<NotificationHub>("/hubs/notifications");
app.Run();

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\AuthController.cs
﻿
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly AuthService _auth;
        public AuthController(AuthService auth) => _auth = auth;


        [HttpPost("register")]
        public async Task<IActionResult> Register([FromForm] RegisterDto dto)
        {
            var res = await _auth.RegisterAsync(dto);
            if (res == null) return Conflict(new { message = "Email already exists" });
            return Ok(res);
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(LoginDto dto)
        {
            var res = await _auth.LoginAsync(dto);
            if (res == null) return Unauthorized(new { message = "Invalid credentials" });
            return Ok(res);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\CategoriesController.cs
﻿using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CategoriesController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public CategoriesController(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        [HttpGet]
        public async Task<IActionResult> GetAll()
        {
            var departments = await _db.Departments
                .ProjectTo<DepartmentDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
            return Ok(departments);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\CommentsController.cs
﻿using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Services;
using Project_Version1.DTOs;
using Project_Version1.Data;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CommentsController : ControllerBase
    {
        private readonly CommentService _commentService;
        private readonly FnfKnowledgeBaseContext _db;

        public CommentsController(CommentService commentService, FnfKnowledgeBaseContext db)
        {
            _commentService = commentService;
            _db = db;
        }

        [HttpGet("post/{postId}")]
        public async Task<IActionResult> GetForPost(int postId, [FromQuery] bool hierarchical = false)
        {
            try
            {
                if (hierarchical)
                {
                    var hierarchicalComments = await _commentService.GetCommentsHierarchyAsync(postId);
                    return Ok(hierarchicalComments);
                }
                else
                {
                    var comments = await _commentService.GetCommentsForPostAsync(postId);
                    return Ok(comments);
                }
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Create([FromBody] CommentCreateDto dto)
        {
            try
            {
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
                var comment = await _commentService.AddCommentAsync(dto, userId);

                if (comment == null)
                {
                    return BadRequest(new { message = "Failed to create comment" });
                }

                return CreatedAtAction(nameof(GetForPost), new { postId = dto.PostId }, comment);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(new { message = ex.Message });
            }
            catch (Exception )
            {
                return StatusCode(500, new { message = "An error occurred while creating the comment" });
            }
        }

        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id, [FromQuery] bool force = false)
        {
            try
            {
                var comment = await _commentService.GetCommentAsync(id);
                if (comment == null) return NotFound();

                var role = User.FindFirstValue(ClaimTypes.Role);
                var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

                // Authorization check
                if (role == "Manager")
                {
                    var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == comment.Post.DeptId);
                    if (manager == null) return Forbid();
                    _db.Commits.Add(new Commit { PostId = comment.PostId, ManagerId = manager.ManagerId, Message = $"Deleted comment {id}" });
                }
                else if (comment.UserId != userId)
                {
                    return Forbid();
                }

                if (force)
                {
                    await _commentService.ForceDeleteCommentAsync(comment);
                }
                else
                {
                    await _commentService.DeleteCommentAsync(comment);
                }

                return NoContent();
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\NotificationsController.cs
﻿
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;
using Project_Version1.Services;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class NotificationsController : ControllerBase
    {
        private readonly NotificationService _notification;
        public NotificationsController(NotificationService notification) => _notification = notification;

        [HttpPost("broadcast")]
        public async Task<IActionResult> Broadcast([FromBody] string message)
        {
            await _notification.BroadcastAsync(message);
            return Ok();
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\PostsController.cs
﻿using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Services;
using Project_Version1.DTOs;
using Project_Version1.Data;
using Project_Version1.Helpers;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class PostsController : ControllerBase
    {
        private readonly PostService _postService;
        private readonly FnfKnowledgeBaseContext _db;

        public PostsController(PostService postService, FnfKnowledgeBaseContext db)
        {
            _postService = postService;
            _db = db;
        }

        [HttpGet("feed")]
        public async Task<IActionResult> Feed(
            [FromQuery] int? deptId,
            [FromQuery] string? tag,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 20)
        {
            var posts = await _postService.GetPostsFeedAsync(deptId, tag, page, pageSize);
            return Ok(posts);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> Get(int id)
        {
            var post = await _postService.GetPostAsync(id);
            if (post == null) return NotFound();
            return Ok(post);
        }

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Create([FromForm] PostCreateDto dto) // ✅ accept multipart/form-data
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            // Fetch the department ID of the logged-in user
            var user = await _db.Users.FirstOrDefaultAsync(u => u.UserId == userId);
            if (user == null || user.DepartmentId == 0)
            {
                return BadRequest("User department information is missing.");
            }

            dto.DeptId = user.DepartmentId;
            int deptId = user.DepartmentId;

            // Create post
            var post = await _postService.CreatePostAsync(dto, userId,deptId);

            // ✅ Handle attachments
            if (dto.Attachments != null && dto.Attachments.Count > 0)
            {
                foreach (var file in dto.Attachments)
                {
                    if (file.Length > 0)
                    {
                        var fileService = HttpContext.RequestServices.GetRequiredService<FileService>();
                        var (fileName, filePath, fileType) = await fileService.SaveFileAsync(file);

                        var attachment = new Attachment
                        {
                            PostId = post.PostId,
                            FileName = fileName,
                            FilePath = filePath,
                            FileType = fileType,
                            UploadedAt = DateTime.UtcNow
                        };

                        _db.Attachments.Add(attachment);
                    }
                }

                await _db.SaveChangesAsync();
            }

            return CreatedAtAction(nameof(Get), new { id = post.PostId }, post);
        }



        [Authorize]
        [HttpPut("{id}")]
        public async Task<IActionResult> Update(int id, [FromBody] PostUpdateDto dto, [FromQuery] string? commitMessage = null)
        {
            var post = await _db.Posts.FindAsync(id);
            if (post == null) return NotFound();

            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role == "Manager")
            {
                var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == post.DeptId);
                if (manager == null) return Forbid();
                if (!string.IsNullOrEmpty(commitMessage))
                {
                    _db.Commits.Add(new Commit { PostId = id, ManagerId = manager.ManagerId, Message = commitMessage });
                }
            }
            else if (post.UserId != userId)
            {
                return Forbid();
            }

            if (!string.IsNullOrEmpty(dto.Title)) post.Title = dto.Title;
            if (!string.IsNullOrEmpty(dto.Body)) post.Body = dto.Body;
            await _postService.UpdatePostAsync(post);
            return NoContent();
        }

        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id, [FromQuery] string? commitMessage = null)
        {
            var post = await _db.Posts.FindAsync(id);
            if (post == null) return NotFound();

            
            var role = User.FindFirstValue(ClaimTypes.Role);
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            if (role == "Manager")
            {
                var manager = await _db.Managers.FirstOrDefaultAsync(m => m.UserId == userId && m.DeptId == post.DeptId);
                if (manager == null) return Forbid();
                if (!string.IsNullOrEmpty(commitMessage))
                {
                    _db.Commits.Add(new Commit { PostId = id, ManagerId = manager.UserId, Message = commitMessage });
                }
            }
            else if (post.UserId != userId)
            {
                return Forbid();
            }

            await _postService.DeletePostAsync(post);
            return NoContent();
        }

        [Authorize]
        [HttpPost("{id}/repost")]
        public async Task<IActionResult> Repost(int id)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            await _postService.RepostAsync(id, userId);
            return Ok();
        }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\TagsController.cs
﻿using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;
using System.Security.Claims;
using System.Threading.Tasks;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TagsController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public TagsController(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        [HttpGet]
        public async Task<IActionResult> Get([FromQuery] int? deptId)
        {
            var query = _db.Tags.AsQueryable();
            if (deptId.HasValue)
                query = query.Where(t => t.DeptId == deptId.Value);

            var tags = await query
                .ProjectTo<TagDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
            return Ok(tags);
        }

        // ✅ Create or get existing tag for logged-in user's dept
        [Authorize]

        [HttpPost]

        public async Task<IActionResult> Create([FromBody] TagCreateDto dto)

        {

            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);

            var user = await _db.Users

                .FirstOrDefaultAsync(u => u.UserId == userId);

            if (user == null)

                return Unauthorized(new { message = "User not found" });

            int deptId = user.DepartmentId;

            var existingTag = await _db.Tags

                .FirstOrDefaultAsync(t => t.TagName.ToLower() == dto.TagName.ToLower()

                                          && t.DeptId == deptId);

            if (existingTag != null)

            {

                var tagDto = _mapper.Map<TagDto>(existingTag);

                return Ok(tagDto);

            }

            var tag = new Tag

            {

                TagName = dto.TagName.Trim(),

                DeptId = deptId

            };

            _db.Tags.Add(tag);

            await _db.SaveChangesAsync();

            var createdDto = _mapper.Map<TagDto>(tag);

            return CreatedAtAction(nameof(Get), new { deptId = deptId }, createdDto);

        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\UsersController.cs
﻿using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Project_Version1.Data;
using Project_Version1.DTOs;
using Project_Version1.Services;
using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class UsersController : ControllerBase
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;
        private readonly AuthService _authService;

        public UsersController(FnfKnowledgeBaseContext db, IMapper mapper, AuthService authService)
        {
            _db = db;
            _mapper = mapper;
            _authService = authService;
        }

        [HttpGet]
        public async Task<ActionResult<List<UserDto>>> GetAll()
        {
            var users = await _db.Users
                .ProjectTo<UserDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
            return Ok(users);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<UserDto>> Get(int id)
        {
            var user = await _db.Users.FindAsync(id);
            if (user == null) return NotFound();

            var userDto = _mapper.Map<UserDto>(user);
            return Ok(userDto);
        }

        [HttpGet("me")]
        [Authorize]
        public async Task<IActionResult> GetProfile()
        {
            // Use ClaimTypes.NameIdentifier (this is what JwtHelper sets)
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
            if (userIdClaim == null) return Unauthorized("User ID not found in token");

            if (!int.TryParse(userIdClaim.Value, out var userId)) return Unauthorized("Invalid user id in token");

            var user = await _db.Users.FindAsync(userId);
            if (user == null) return NotFound();

            var dto = _mapper.Map<UserDto>(user);
            return Ok(dto);
        }

        [Authorize]
        [HttpPut("update-profile")]
        public async Task<IActionResult> UpdateProfile([FromForm] UserUpdateDto dto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);

            if (userIdClaim == null) return Unauthorized("User ID not found in token");

            if (!int.TryParse(userIdClaim.Value, out var userId)) return Unauthorized("Invalid user id in token");

            var updatedUser = await _authService.UpdateProfileAsync(userId, dto);

            if (updatedUser == null) return NotFound("User not found");

            return Ok(updatedUser);
        }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Controllers\VotesController.cs
﻿
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using System.Threading.Tasks;
using Project_Version1.Services;
using Project_Version1.DTOs;

namespace Project_Version1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class VotesController : ControllerBase
    {
        private readonly VoteService _voteService;
        public VotesController(VoteService voteService) => _voteService = voteService;

        [Authorize]
        [HttpPost]
        public async Task<IActionResult> Vote([FromBody] VoteDto dto)
        {
            var userId = int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier)!);
            var ok = await _voteService.VoteAsync(dto, userId);
            if (!ok) return BadRequest();
            return Ok();
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Attachment.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Attachment
{
    public int AttachmentId { get; set; }

    public int? PostId { get; set; }

    public int? CommentId { get; set; }

    public string FileName { get; set; } = null!;

    public string FilePath { get; set; } = null!;

    public string FileType { get; set; } 

    public DateTime UploadedAt { get; set; }

    public virtual Comment? Comment { get; set; }

    public virtual Post? Post { get; set; }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Comment.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Comment
{
    public int CommentId { get; set; }

    public int PostId { get; set; }

    public int UserId { get; set; }

    public int? ParentCommentId { get; set; }

    public string CommentText { get; set; } = null!;

    public DateTime CreatedAt { get; set; }

    public DateTime? UpdatedAt { get; set; }

    public virtual ICollection<Attachment> Attachments { get; set; } = new List<Attachment>();

    public virtual ICollection<Comment> InverseParentComment { get; set; } = new List<Comment>();

    public virtual Comment? ParentComment { get; set; }

    public virtual Post Post { get; set; } = null!;

    public virtual User User { get; set; } = null!;

    public virtual ICollection<Vote> Votes { get; set; } = new List<Vote>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Commit.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Commit
{
    public int CommitId { get; set; }

    public int PostId { get; set; }

    public int ManagerId { get; set; }

    public string Message { get; set; } = null!;

    public DateTime CreatedAt { get; set; }

    public virtual Manager Manager { get; set; } = null!;

    public virtual Post Post { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Department.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Department
{
    public int DeptId { get; set; }

    public string DeptName { get; set; } = null!;

    public virtual ICollection<Manager> Managers { get; set; } = new List<Manager>();

    public virtual ICollection<Post> Posts { get; set; } = new List<Post>();

    public virtual ICollection<Tag> Tags { get; set; } = new List<Tag>();

    public virtual ICollection<User> Users { get; set; } = new List<User>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\FnfKnowledgeBaseContext.cs
﻿using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;

namespace Project_Version1.Data;

public partial class FnfKnowledgeBaseContext : DbContext
{
    public FnfKnowledgeBaseContext()
    {
    }

    public FnfKnowledgeBaseContext(DbContextOptions<FnfKnowledgeBaseContext> options)
        : base(options)
    {
    }

    public virtual DbSet<Attachment> Attachments { get; set; }

    public virtual DbSet<Comment> Comments { get; set; }

    public virtual DbSet<Commit> Commits { get; set; }

    public virtual DbSet<Department> Departments { get; set; }

    public virtual DbSet<Manager> Managers { get; set; }

    public virtual DbSet<Post> Posts { get; set; }

    public virtual DbSet<PostTag> PostTags { get; set; }

    public virtual DbSet<Repost> Reposts { get; set; }

    public virtual DbSet<Tag> Tags { get; set; }

    public virtual DbSet<User> Users { get; set; }

    public virtual DbSet<Vote> Votes { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
#warning To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see https://go.microsoft.com/fwlink/?LinkId=723263.
        => optionsBuilder.UseSqlServer("Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=FNF_KnowledgeBase;Integrated Security=True;Encrypt=False");

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Attachment>(entity =>
        {
            entity.HasKey(e => e.AttachmentId).HasName("PK__Attachme__442C64BEA7A7576E");

            entity.Property(e => e.FileName).HasMaxLength(200);
            entity.Property(e => e.FilePath).HasMaxLength(500);
            entity.Property(e => e.FileType).HasMaxLength(20);
            entity.Property(e => e.UploadedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");

            entity.HasOne(d => d.Comment).WithMany(p => p.Attachments)
                .HasForeignKey(d => d.CommentId)
                .HasConstraintName("FK__Attachmen__Comme__5070F446");

            entity.HasOne(d => d.Post).WithMany(p => p.Attachments)
                .HasForeignKey(d => d.PostId)
                .HasConstraintName("FK__Attachmen__PostI__4F7CD00D");
        });

        modelBuilder.Entity<Comment>(entity =>
        {
            entity.HasKey(e => e.CommentId).HasName("PK__Comments__C3B4DFCA01D3F462");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.UpdatedAt).HasColumnType("datetime");

            entity.HasOne(d => d.ParentComment).WithMany(p => p.InverseParentComment)
                .HasForeignKey(d => d.ParentCommentId)
                .HasConstraintName("FK__Comments__Parent__3F466844");

            entity.HasOne(d => d.Post).WithMany(p => p.Comments)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Comments__PostId__3D5E1FD2");

            entity.HasOne(d => d.User).WithMany(p => p.Comments)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Comments__UserId__3E52440B");
        });

        modelBuilder.Entity<Commit>(entity =>
        {
            entity.HasKey(e => e.CommitId).HasName("PK__Commits__73748B724CFAE850");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");

            entity.HasOne(d => d.Manager).WithMany(p => p.Commits)
                .HasForeignKey(d => d.ManagerId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Commits__Manager__59FA5E80");

            entity.HasOne(d => d.Post).WithMany(p => p.Commits)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Commits__PostId__59063A47");
        });

        modelBuilder.Entity<Department>(entity =>
        {
            entity.HasKey(e => e.DeptId).HasName("PK__Departme__014881AEFE7D8A9E");

            entity.HasIndex(e => e.DeptName, "UQ__Departme__5E5082657BEFDBB4").IsUnique();

            entity.Property(e => e.DeptName).HasMaxLength(200);
        });

        modelBuilder.Entity<Manager>(entity =>
        {
            entity.HasKey(e => e.ManagerId).HasName("PK__Managers__3BA2AAE14CC2F4A3");

            entity.HasIndex(e => e.UserId, "UQ__Managers__1788CC4DE8C2BF2C").IsUnique();

            entity.HasOne(d => d.Dept).WithMany(p => p.Managers)
                .HasForeignKey(d => d.DeptId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Managers__DeptId__4AB81AF0");

            entity.HasOne(d => d.User).WithOne(p => p.Manager)
                .HasForeignKey<Manager>(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Managers__UserId__49C3F6B7");
        });

        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.PostId).HasName("PK__Posts__AA126018472F972E");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.Title).HasMaxLength(500);
            entity.Property(e => e.UpdatedAt).HasColumnType("datetime");

            entity.HasOne(d => d.Dept).WithMany(p => p.Posts)
                .HasForeignKey(d => d.DeptId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Posts__DeptId__35BCFE0A");

            entity.HasOne(d => d.User).WithMany(p => p.Posts)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Posts__UserId__34C8D9D1");
        });

        modelBuilder.Entity<PostTag>(entity =>
        {
            entity.HasKey(e => e.PostTagId).HasName("PK__PostTags__325724FD3E737958");

            entity.HasOne(d => d.Post).WithMany(p => p.PostTags)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__PostTags__PostId__38996AB5");

            entity.HasOne(d => d.Tag).WithMany(p => p.PostTags)
                .HasForeignKey(d => d.TagId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__PostTags__TagId__398D8EEE");
        });

        modelBuilder.Entity<Repost>(entity =>
        {
            entity.HasKey(e => e.RepostId).HasName("PK__Reposts__5E7F921EDF28218B");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");

            entity.HasOne(d => d.Post).WithMany(p => p.Reposts)
                .HasForeignKey(d => d.PostId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Reposts__PostId__5441852A");

            entity.HasOne(d => d.User).WithMany(p => p.Reposts)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Reposts__UserId__5535A963");
        });

        modelBuilder.Entity<Tag>(entity =>
        {
            entity.HasKey(e => e.TagId).HasName("PK__Tags__657CF9ACE13ACE18");

            entity.HasIndex(e => e.TagName, "UQ__Tags__BDE0FD1D27F47ECD").IsUnique();

            entity.Property(e => e.TagName).HasMaxLength(200);

            entity.HasOne(d => d.Dept).WithMany(p => p.Tags)
                .HasForeignKey(d => d.DeptId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Tags__DeptId__2E1BDC42");
        });

        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.UserId).HasName("PK__Users__1788CC4CFDF19873");

            entity.HasIndex(e => e.Email, "UQ__Users__A9D10534FBED8653").IsUnique();

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.Email).HasMaxLength(200);
            entity.Property(e => e.FullName).HasMaxLength(200);
            entity.Property(e => e.PasswordHash).HasMaxLength(500);
            entity.Property(e => e.ProfilePicture).HasMaxLength(500);
            entity.Property(e => e.Role).HasMaxLength(20);

            entity.HasOne(d => d.Department).WithMany(p => p.Users)
                .HasForeignKey(d => d.DepartmentId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Users__Departmen__2A4B4B5E");
        });

        modelBuilder.Entity<Vote>(entity =>
        {
            entity.HasKey(e => e.VoteId).HasName("PK__Votes__52F015C2FC0ED114");

            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.VoteType).HasMaxLength(20);

            entity.HasOne(d => d.Comment).WithMany(p => p.Votes)
                .HasForeignKey(d => d.CommentId)
                .HasConstraintName("FK__Votes__CommentId__44FF419A");

            entity.HasOne(d => d.Post).WithMany(p => p.Votes)
                .HasForeignKey(d => d.PostId)
                .HasConstraintName("FK__Votes__PostId__440B1D61");

            entity.HasOne(d => d.User).WithMany(p => p.Votes)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Votes__UserId__45F365D3");
        });

        OnModelCreatingPartial(modelBuilder);
    }

    partial void OnModelCreatingPartial(ModelBuilder modelBuilder);
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Manager.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Manager
{
    public int ManagerId { get; set; }

    public int UserId { get; set; }

    public int DeptId { get; set; }

    public virtual ICollection<Commit> Commits { get; set; } = new List<Commit>();

    public virtual Department Dept { get; set; } = null!;

    public virtual User User { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Post.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Post
{
    public int PostId { get; set; }

    public int UserId { get; set; }

    public int DeptId { get; set; }

    public string Title { get; set; } = null!;

    public string Body { get; set; } = null!;

    public int? UpvoteCount { get; set; }

    public int? DownvoteCount { get; set; }

    public DateTime CreatedAt { get; set; }

    public DateTime? UpdatedAt { get; set; }

    public bool IsRepost { get; set; }

    public virtual ICollection<Attachment> Attachments { get; set; } = new List<Attachment>();

    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();

    public virtual ICollection<Commit> Commits { get; set; } = new List<Commit>();

    public virtual Department Dept { get; set; } = null!;

    public virtual ICollection<PostTag> PostTags { get; set; } = new List<PostTag>();

    public virtual ICollection<Repost> Reposts { get; set; } = new List<Repost>();

    public virtual User User { get; set; } = null!;

    public virtual ICollection<Vote> Votes { get; set; } = new List<Vote>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\PostTag.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class PostTag
{
    public int PostTagId { get; set; }

    public int PostId { get; set; }

    public int TagId { get; set; }

    public virtual Post Post { get; set; } = null!;

    public virtual Tag Tag { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Repost.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Repost
{
    public int RepostId { get; set; }

    public int PostId { get; set; }

    public int UserId { get; set; }

    public DateTime CreatedAt { get; set; }

    public virtual Post Post { get; set; } = null!;

    public virtual User User { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Tag.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Tag
{
    public int TagId { get; set; }

    public string TagName { get; set; } = null!;

    public int DeptId { get; set; }

    public virtual Department Dept { get; set; } = null!;

    public virtual ICollection<PostTag> PostTags { get; set; } = new List<PostTag>();
}
public class TagCreateDto
{
    public string TagName { get; set; } = string.Empty;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\User.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class User
{
    public int UserId { get; set; }

    public string FullName { get; set; } = null!;

    public string Email { get; set; } = null!;

    public string PasswordHash { get; set; } = null!;

    public string Role { get; set; } = null!;

    public string? ProfilePicture { get; set; }

    public int DepartmentId { get; set; }

    public DateTime CreatedAt { get; set; }

    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();

    public virtual Department Department { get; set; } = null!;

    public virtual Manager? Manager { get; set; }

    public virtual ICollection<Post> Posts { get; set; } = new List<Post>();

    public virtual ICollection<Repost> Reposts { get; set; } = new List<Repost>();

    public virtual ICollection<Vote> Votes { get; set; } = new List<Vote>();
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Data\Vote.cs
﻿using System;
using System.Collections.Generic;

namespace Project_Version1.Data;

public partial class Vote
{
    public int VoteId { get; set; }

    public int? PostId { get; set; }

    public int? CommentId { get; set; }

    public int UserId { get; set; }

    public string VoteType { get; set; } = null!;

    public DateTime CreatedAt { get; set; }

    public virtual Comment? Comment { get; set; }

    public virtual Post? Post { get; set; }

    public virtual User User { get; set; } = null!;
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\AuthDtos.cs
﻿
namespace Project_Version1.DTOs
{
    public class RegisterDto
    {
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string Role { get; set; } = "Employee";
        public int? DepartmentId { get; set; }
        public IFormFile? ProfilePicture { get; set; } // ✅

    }

    public class LoginDto
    {
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
    }

    public class AuthResponseDto
    {
        public string Token { get; set; } = null!;
        public int UserId { get; set; }
        public string Role { get; set; } = null!;
        public string? ProfilePicture { get; set; } // ✅ return stored path
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\CommentDtos.cs
﻿
using System;

namespace Project_Version1.DTOs
{
    public class CommentCreateDto
    {
        public int PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
    }

    public class CommentDto
    {
        public int CommentId { get; set; }
        public int PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
        public string? AuthorName { get; set; }
        public DateTime CreatedAt { get; set; }
    }
     public class CommentWithRepliesDto
    {
        public int CommentId { get; set; }
        public int PostId { get; set; }
        public int? ParentCommentId { get; set; }
        public string CommentText { get; set; } = null!;
        public string? AuthorName { get; set; }
        public DateTime CreatedAt { get; set; }
        public List<CommentWithRepliesDto> Replies { get; set; } = new List<CommentWithRepliesDto>();
    }

    // Enhanced comment DTO with additional info
    public class CommentDetailDto : CommentDto
    {
        public bool IsDeleted { get; set; }
        public DateTime? UpdatedAt { get; set; }
        public int ReplyCount { get; set; }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\DepartmentDto.cs
﻿namespace Project_Version1.DTOs
{
    public class DepartmentDto
    {
        public int DeptId { get; set; }
        public string DeptName { get; set; } = null!;
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\PostDtos.cs
﻿using Microsoft.AspNetCore.Http;
using System.Collections.Generic;

namespace Project_Version1.DTOs
{
    public class PostCreateDto
    {
        public int DeptId { get; set; }
        public string Title { get; set; } 
        public string Body { get; set; }
        public List<string>? Tags { get; set; }

        // ✅ New: Attachments (multiple files allowed)
        public List<IFormFile>? Attachments { get; set; }
    }

    public class PostUpdateDto
    {
        public string? Title { get; set; }
        public string? Body { get; set; }
    }

    public class PostBriefDto
    {
        public int PostId { get; set; }
        public string Title { get; set; } = null!;
        public string BodyPreview { get; set; } = null!;
        public int? UpvoteCount { get; set; }
        public int DownvoteCount { get; set; }
        public int CommentsCount { get; set; }
        public DateTime CreatedAt { get; set; }
        public string? AuthorName { get; set; }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\TagDto.cs
﻿namespace Project_Version1.DTOs
{
    public class TagDto
    {
        public int TagId { get; set; }
        public string TagName { get; set; } = null!;
        public int DeptId { get; set; }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\UserDtos.cs
﻿namespace Project_Version1.DTOs
{
    public class UserDto
    {
        public int UserId { get; set; }
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Role { get; set; } = null!;
        public int? DepartmentId { get; set; }
        public string? ProfilePicture { get; set; } // path/url to stored file
    }

    public class UserCreateDto
    {
        public string FullName { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string Role { get; set; } = "Employee";
        public int? DepartmentId { get; set; }
        public IFormFile? ProfilePicture { get; set; }
    }

    public class UserUpdateDto
    {
        public string? FullName { get; set; }
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
        public int? DepartmentId { get; set; }
        public IFormFile? ProfilePicture { get; set; } // optional new upload
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\DTOs\VoteDtos.cs
﻿
namespace Project_Version1.DTOs
{
    public class VoteDto
    {
        public int? PostId { get; set; }
        public int? CommentId { get; set; }
        public string VoteType { get; set; } // "Upvote" or "Downvote"
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Helpers\JwtHelper.cs
﻿using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using Project_Version1.Data;

namespace Project_Version1.Helpers
{
    public class JwtHelper
    {
        private readonly IConfiguration _config;
        public JwtHelper(IConfiguration config) => _config = config;

        public string GenerateToken(User user)
        {
            var jwt = _config.GetSection("Jwt");
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwt["Key"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, user.UserId.ToString()),
                new Claim(ClaimTypes.Name, user.FullName ?? string.Empty),
                new Claim(ClaimTypes.Email, user.Email ?? string.Empty),
                new Claim(ClaimTypes.Role, user.Role ?? "Employee"),
                new Claim("DeptId", user.DepartmentId.ToString())
            };

            var token = new JwtSecurityToken(
                issuer: jwt["Issuer"],
                audience: jwt["Audience"],
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(jwt["ExpireMinutes"] ?? "100")),
                signingCredentials: creds
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Helpers\PaginationHelper.cs
﻿
using System;
using System.Linq;

namespace Project_Version1.Helpers
{
    public static class PaginationHelper
    {
        public static IQueryable<T> Paginate<T>(IQueryable<T> query, int page, int pageSize)
        {
            if (page < 1) page = 1;
            if (pageSize < 1) pageSize = 20;
            return query.Skip((page - 1) * pageSize).Take(pageSize);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Helpers\PasswordHasher.cs
﻿
using System;
using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using System.Security.Cryptography;

namespace Project_Version1.Helpers
{
    public static class PasswordHasher
    {
        // Produces salted hash: salt.hash
        public static string Hash(string password)
        {
            byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
            string saltStr = Convert.ToBase64String(salt);
            var hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: password,
                salt: salt,
                prf: KeyDerivationPrf.HMACSHA256,
                iterationCount: 100_000,
                numBytesRequested: 256 / 8));

            return $"{saltStr}.{hashed}";
        }

        public static bool Verify(string password, string stored)
        {
            if (string.IsNullOrWhiteSpace(stored)) return false;
            var parts = stored.Split('.');
            if (parts.Length != 2) return false;
            var salt = Convert.FromBase64String(parts[0]);
            var expected = parts[1];

            var hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: password,
                salt: salt,
                prf: KeyDerivationPrf.HMACSHA256,
                iterationCount: 100_000,
                numBytesRequested: 256 / 8));

            return hashed == expected;
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Helpers\SignalRHub.cs
﻿using Microsoft.AspNetCore.SignalR;
using System.Threading.Tasks;

namespace Project_Version1.Helpers
{

    public class NotificationHub : Hub
    {
        public async Task SendToUser(string userId, string message)
        {
            await Clients.User(userId).SendAsync("ReceiveNotification", message);
        }

        public async Task Broadcast(string message)
        {
            await Clients.All.SendAsync("ReceiveNotification", message);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Profiles\MappingProfile.cs
﻿using AutoMapper;
using Project_Version1.Data;
using Project_Version1.DTOs;
using System.Linq;

namespace Project_Version1.Profiles
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            // User mappings
            CreateMap<User, UserDto>()
                .ForMember(dest => dest.Role, opt => opt.MapFrom(src => src.Role ?? "Employee"))
                .ForMember(dest => dest.ProfilePicture, opt => opt.MapFrom(src => src.ProfilePicture));

            CreateMap<UserCreateDto, User>()
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()) // Handle separately
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());

            CreateMap<UserUpdateDto, User>()
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()) // Handle separately
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.ProfilePicture, opt => opt.Ignore())
                .ForMember(dest => dest.Email, opt => opt.Ignore())
                .ForAllMembers(opts => opts.Condition((src, dest, srcMember) => srcMember != null)); // Ignore nulls

            CreateMap<RegisterDto, User>()
                .ForMember(dest => dest.PasswordHash, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());

            // Post mappings
            CreateMap<PostCreateDto, Post>()
                .ForMember(dest => dest.PostId, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore()) // Set in service
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpvoteCount, opt => opt.MapFrom(src => 0))
                .ForMember(dest => dest.DownvoteCount, opt => opt.MapFrom(src => 0))
            .ForMember(dest => dest.IsRepost, opt => opt.MapFrom(src => false))
            .ForMember(dest => dest.Attachments, opt => opt.Ignore()) // Handle attachments separately
                .ForMember(dest => dest.PostTags, opt => opt.Ignore()); // Handle tags separately

            CreateMap<Post, PostBriefDto>()
                .ForMember(dest => dest.BodyPreview, opt => opt.MapFrom(src =>
                    string.IsNullOrEmpty(src.Body) ? string.Empty :
                    src.Body.Length > 200 ? src.Body.Substring(0, 200) + "..." : src.Body))
                .ForMember(dest => dest.UpvoteCount, opt => opt.MapFrom(src => src.UpvoteCount ?? 0))
                .ForMember(dest => dest.DownvoteCount, opt => opt.MapFrom(src => src.DownvoteCount ?? 0))
                .ForMember(dest => dest.CommentsCount, opt => opt.MapFrom(src =>
                    src.Comments != null ? src.Comments.Count : 0))
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName));

            // Comment mappings
            CreateMap<CommentCreateDto, Comment>()
                .ForMember(dest => dest.CommentId, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
                .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore());

            CreateMap<Comment, CommentDto>()
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName));

            // Use the "with replies" DTO but ignore Replies mapping (the service builds hierarchy manually)
            CreateMap<Comment, CommentWithRepliesDto>()
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.Replies, opt => opt.Ignore());

            CreateMap<Comment, CommentDetailDto>()
                .ForMember(dest => dest.AuthorName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.IsDeleted, opt => opt.MapFrom(src => src.CommentText == "[Comment deleted]"))
                .ForMember(dest => dest.ReplyCount, opt => opt.MapFrom(src => src.InverseParentComment != null ? src.InverseParentComment.Count : 0));

            CreateMap<VoteDto, Vote>()
                .ForMember(dest => dest.VoteId, opt => opt.Ignore())
                .ForMember(dest => dest.UserId, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());

            // Tag mappings
            CreateMap<Tag, TagDto>()
                .ForMember(dest => dest.TagId, opt => opt.MapFrom(src => src.TagId))
                .ForMember(dest => dest.TagName, opt => opt.MapFrom(src => src.TagName))
                .ForMember(dest => dest.DeptId, opt => opt.MapFrom(src => src.DeptId));

            CreateMap<Department, DepartmentDto>()
                .ForMember(dest => dest.DeptId, opt => opt.MapFrom(src => src.DeptId))
                .ForMember(dest => dest.DeptName, opt => opt.MapFrom(src => src.DeptName));
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Services\AuthService.cs
﻿using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using Project_Version1.Data;
using Project_Version1.DTOs;
using Project_Version1.Helpers;

namespace Project_Version1.Services
{
    public class AuthService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly JwtHelper _jwt;
        private readonly IMapper _mapper;
        private readonly IWebHostEnvironment _env;

        public AuthService(FnfKnowledgeBaseContext db, JwtHelper jwt, IMapper mapper, IWebHostEnvironment env)
        {
            _db = db;
            _jwt = jwt;
            _mapper = mapper;
            _env = env;
        }

        public async Task<AuthResponseDto?> RegisterAsync(RegisterDto dto)
        {
            var exists = await _db.Users.AnyAsync(u => u.Email == dto.Email);
            if (exists) return null;

            var user = _mapper.Map<User>(dto);
            user.PasswordHash = PasswordHasher.Hash(dto.Password);
            user.CreatedAt = DateTime.UtcNow;

            // Handle profile picture upload
            if (dto.ProfilePicture != null && dto.ProfilePicture.Length > 0)
            {   
                var uploadsFolder = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot/uploads/profile-pics");
                if (!Directory.Exists(uploadsFolder))
                    Directory.CreateDirectory(uploadsFolder);

                var fileName = $"{Guid.NewGuid()}{Path.GetExtension(dto.ProfilePicture.FileName)}";
                var filePath = Path.Combine(uploadsFolder, fileName);

                using (var stream = new FileStream(filePath, FileMode.Create))
                {
                    await dto.ProfilePicture.CopyToAsync(stream);
                }

                user.ProfilePicture = $"/uploads/profile-pics/{fileName}";
            }

            _db.Users.Add(user);
            await _db.SaveChangesAsync();

            var token = _jwt.GenerateToken(user);
            return new AuthResponseDto
            {
                Token = token,
                UserId = user.UserId,
                Role = user.Role ?? "Employee"
            };
        }
        public async Task<AuthResponseDto?> LoginAsync(LoginDto dto)
        {
            var user = await _db.Users.FirstOrDefaultAsync(u => u.Email == dto.Email);
            if (user == null || !PasswordHasher.Verify(dto.Password, user.PasswordHash))
                return null;

            var token = _jwt.GenerateToken(user);
            return new AuthResponseDto
            {
                Token = token,
                UserId = user.UserId,
                Role = user.Role ?? "Employee",
                ProfilePicture = user.ProfilePicture // ✅ add this
            };
        }
        public async Task<UserDto?> UpdateProfileAsync(int userId, UserUpdateDto dto)
        {
            var user = await _db.Users.FirstOrDefaultAsync(u => u.UserId == userId);
            if (user == null) return null;

            // Update basic fields
            if (!string.IsNullOrEmpty(dto.FullName))
                user.FullName = dto.FullName;

            if (dto.DepartmentId.HasValue)
                user.DepartmentId = dto.DepartmentId.Value;

            if(!string.IsNullOrEmpty(dto.Email))
                user.Email = dto.Email;
            if (!string.IsNullOrEmpty(dto.Password))
                user.PasswordHash = PasswordHasher.Hash(dto.Password);
            if (dto.ProfilePicture != null && dto.ProfilePicture.Length > 0)
            {
                var uploadsFolder = Path.Combine(_env.WebRootPath, "uploads/profile-pics");
                if (!Directory.Exists(uploadsFolder))
                    Directory.CreateDirectory(uploadsFolder);

                var fileName = $"{Guid.NewGuid()}{Path.GetExtension(dto.ProfilePicture.FileName)}";
                var filePath = Path.Combine(uploadsFolder, fileName);

                using (var stream = new FileStream(filePath, FileMode.Create))
                {
                    await dto.ProfilePicture.CopyToAsync(stream);
                }
                if (!string.IsNullOrEmpty(user.ProfilePicture))
                {
                    var oldFile = Path.Combine(_env.WebRootPath, user.ProfilePicture.TrimStart('/'));
                    if (File.Exists(oldFile))
                        File.Delete(oldFile);
                }

                user.ProfilePicture = $"/uploads/profile-pics/{fileName}";
            }

            await _db.SaveChangesAsync();

            return _mapper.Map<UserDto>(user);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Services\CommentService.cs
﻿using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using AutoMapper.QueryableExtensions;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class CommentService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public CommentService(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        public async Task<Comment?> AddCommentAsync(CommentCreateDto dto, int userId)
        {
            // Validate that the post exists
            var postExists = await _db.Posts.AnyAsync(p => p.PostId == dto.PostId);
            if (!postExists)
            {
                throw new ArgumentException($"Post with ID {dto.PostId} does not exist.");
            }

            // If this is a reply, validate that the parent comment exists and belongs to the same post
            if (dto.ParentCommentId.HasValue && dto.ParentCommentId.Value > 0)
            {
                var parentComment = await _db.Comments
                    .FirstOrDefaultAsync(c => c.CommentId == dto.ParentCommentId.Value);

                if (parentComment == null)
                {
                    throw new ArgumentException($"Parent comment with ID {dto.ParentCommentId.Value} does not exist.");
                }

                if (parentComment.PostId != dto.PostId)
                {
                    throw new ArgumentException("Parent comment must belong to the same post.");
                }
            }
            else
            {
                dto.ParentCommentId = null; // ✅ treat 0 as null
            }


            var comment = _mapper.Map<Comment>(dto);
            comment.UserId = userId;
            comment.CreatedAt = DateTime.UtcNow;

            _db.Comments.Add(comment);
            await _db.SaveChangesAsync();

            // Return the comment with user information
            return await _db.Comments
                .Include(c => c.User)
                .FirstOrDefaultAsync(c => c.CommentId == comment.CommentId);
        }

        public async Task<List<CommentDto>> GetCommentsForPostAsync(int postId)
        {
            return await _db.Comments
                .Where(c => c.PostId == postId)
                .Include(c => c.User)
                .OrderBy(c => c.CreatedAt) // Root comments first, then replies
                .ProjectTo<CommentDto>(_mapper.ConfigurationProvider)
                .ToListAsync();
        }

        // Get hierarchical comments (nested structure)
        public async Task<List<CommentWithRepliesDto>> GetCommentsHierarchyAsync(int postId)
        {
            var allComments = await _db.Comments
                .Where(c => c.PostId == postId)
                .Include(c => c.User)
                .OrderBy(c => c.CreatedAt)
                .ToListAsync();

            // Build hierarchy
            var commentDtos = _mapper.Map<List<CommentWithRepliesDto>>(allComments);
            var commentDict = commentDtos.ToDictionary(c => c.CommentId);

            var rootComments = new List<CommentWithRepliesDto>();

            foreach (var comment in commentDtos)
            {
                if (comment.ParentCommentId.HasValue && commentDict.ContainsKey(comment.ParentCommentId.Value))
                {
                    // This is a reply
                    commentDict[comment.ParentCommentId.Value].Replies.Add(comment);
                }
                else
                {
                    // This is a root comment
                    rootComments.Add(comment);
                }
            }

            return rootComments;
        }

        public async Task<Comment?> GetCommentAsync(int commentId)
        {
            return await _db.Comments
                .Include(c => c.User)
                .Include(c => c.Post)
                .FirstOrDefaultAsync(c => c.CommentId == commentId);
        }

        public async Task DeleteCommentAsync(Comment comment)
        {
            // Check if comment has replies
            var hasReplies = await _db.Comments.AnyAsync(c => c.ParentCommentId == comment.CommentId);

            if (hasReplies)
            {
                // Option 1: Mark as deleted instead of actually deleting
                comment.CommentText = "[Comment deleted]";
                comment.UpdatedAt = DateTime.UtcNow;
                _db.Comments.Update(comment);
            }
            else
            {
                // Option 2: Actually delete if no replies
                _db.Comments.Remove(comment);
            }

            await _db.SaveChangesAsync();
        }

        // Alternative: Force delete with cascading
        public async Task ForceDeleteCommentAsync(Comment comment)
        {
            // First delete all replies recursively
            await DeleteCommentAndRepliesRecursively(comment.CommentId);
            await _db.SaveChangesAsync();
        }

        private async Task DeleteCommentAndRepliesRecursively(int commentId)
        {
            var replies = await _db.Comments
                .Where(c => c.ParentCommentId == commentId)
                .ToListAsync();

            foreach (var reply in replies)
            {
                await DeleteCommentAndRepliesRecursively(reply.CommentId);
            }

            var comment = await _db.Comments.FindAsync(commentId);
            if (comment != null)
            {
                _db.Comments.Remove(comment);
            }
        }
    }
}


// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Services\FileService.cs
﻿
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Project_Version1.Data;

namespace Project_Version1.Services
{
    public class FileService
    {
        private readonly IWebHostEnvironment _env;
        public FileService(IWebHostEnvironment env) => _env = env;

        public async Task<(string fileName, string filePath,string fileType)> SaveFileAsync(IFormFile file)
        {
            var rootPath = _env.WebRootPath;
            if (string.IsNullOrEmpty(rootPath))
            {
                rootPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot");
            }
            var uploads = Path.Combine(rootPath, "uploads","attachments");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            var fileName = $"{Guid.NewGuid()}_{Path.GetFileName(file.FileName)}";
            var filePath = Path.Combine(uploads, fileName);

            using (var fs = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(fs);
            }

            var relativePath = $"/uploads/attachments/{fileName}";
            var extension= Path.GetExtension(file.FileName).ToLower();
            string fileType= extension switch
            {
                ".jpg" or ".jpeg" or ".png" or ".gif" => "image",
                ".pdf" => "pdf",
                ".doc" or ".docx" => "word",
                ".xls" or ".xlsx" => "excel",
                ".ppt" or ".pptx" => "powerpoint",
                ".txt" => "text",
                _ => "other"
            };
            return (fileName, relativePath, fileType);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Services\NotificationService.cs
﻿
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR;
using Project_Version1.Data;
using Project_Version1.Helpers;

namespace Project_Version1.Services
{
    public class NotificationService
    {
        private readonly IHubContext<NotificationHub> _hub;
        private readonly FnfKnowledgeBaseContext _db;
        public NotificationService(IHubContext<NotificationHub> hub, FnfKnowledgeBaseContext db)
        {
            _hub = hub; _db = db;
        }

        public async Task NotifyUserAsync(int userId, string message)
        {
            // you might persist notifications to DB table in future
            await _hub.Clients.User(userId.ToString()).SendAsync("ReceiveNotification", message);
        }

        public async Task BroadcastAsync(string message)
        {
            await _hub.Clients.All.SendAsync("ReceiveNotification", message);
        }
    }
}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Services\PostService.cs
﻿using System;

using System.Collections.Generic;

using System.IO;

using System.Linq;

using System.Threading.Tasks;

using Microsoft.EntityFrameworkCore;

using AutoMapper;

using Project_Version1.Data;

using Project_Version1.DTOs;

using Microsoft.AspNetCore.Hosting;

using Microsoft.AspNetCore.Http;

namespace Project_Version1.Services

{

    public class PostService

    {

        private readonly FnfKnowledgeBaseContext _db;

        private readonly IMapper _mapper;

        private readonly IWebHostEnvironment _env;
        private readonly FileService _fileService;
        public PostService(FnfKnowledgeBaseContext db, IMapper mapper, IWebHostEnvironment env, FileService fileService )

        {

            _db = db;

            _mapper = mapper;

            _env = env;
            _fileService = fileService;
        }

        public async Task<Post> CreatePostAsync(PostCreateDto dto, int userId, int deptId)

        {

            var post = _mapper.Map<Post>(dto);

            post.UserId = userId;

            post.DeptId = deptId;

            post.CreatedAt = DateTime.UtcNow;

            _db.Posts.Add(post);

            await _db.SaveChangesAsync();

            // Handle Tags

            if (dto.Tags != null && dto.Tags.Any())

            {

                foreach (var tagName in dto.Tags.Distinct())

                {

                    var tag = await _db.Tags.FirstOrDefaultAsync(

                        x => x.TagName == tagName && x.DeptId == deptId);

                    if (tag == null)

                    {

                        tag = new Tag { TagName = tagName, DeptId = deptId };

                        _db.Tags.Add(tag);

                        await _db.SaveChangesAsync();

                    }

                    _db.PostTags.Add(new PostTag { PostId = post.PostId, TagId = tag.TagId });

                }

                await _db.SaveChangesAsync();

            }

            // Handle Attachments
            //if (dto.Attachments != null && dto.Attachments.Any())

            //{

            //    foreach (var file in dto.Attachments)

            //    {

            //        var (fileName,filePath, fileType) = await _fileService.SaveFileAsync(file);

            //        using (var stream = new FileStream(filePath, FileMode.Create))

            //        {

            //            await file.CopyToAsync(stream);

            //        }

            //        var attachment = new Attachment

            //        {

            //            PostId = post.PostId,

            //            FileName = file.FileName,

            //            FilePath = filePath, // Store in consistent format

            //            FileType = fileType,            
            //            UploadedAt = DateTime.UtcNow


            //        };

            //_db.Attachments.Add(attachment);

            //}

            //await _db.SaveChangesAsync();
            // Handle Attachments
            if (dto.Attachments != null && dto.Attachments.Any())
            {
                foreach (var file in dto.Attachments)
                {
                    var (fileName, filePath, fileType) = await _fileService.SaveFileAsync(file);

                    var attachment = new Attachment
                    {
                        PostId = post.PostId,
                        FileName = file.FileName,
                        FilePath = filePath, // This is the relative path
                        FileType = fileType,
                        UploadedAt = DateTime.UtcNow
                    };

                    _db.Attachments.Add(attachment);
                }

                await _db.SaveChangesAsync();
            }


            return post;

        }

        public IQueryable<Post> QueryPosts() =>

            _db.Posts

               .Include(p => p.User)

               .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)

               .Include(p => p.Comments)

               .Include(p => p.Reposts);

        public async Task<Post?> GetPostAsync(int id) =>

            await _db.Posts

                .Include(p => p.User)

                .Include(p => p.PostTags).ThenInclude(pt => pt.Tag)

                .Include(p => p.Comments).ThenInclude(c => c.User)

                .Include(p => p.Attachments)

                .FirstOrDefaultAsync(p => p.PostId == id);

        public async Task<List<PostBriefDto>> GetPostsFeedAsync(int? deptId, string? tag, int page, int pageSize)

        {

            var query = _db.Posts.AsQueryable();

            if (deptId.HasValue)

                query = query.Where(p => p.DeptId == deptId.Value);

            if (!string.IsNullOrEmpty(tag))

                query = query.Where(p => p.PostTags.Any(pt => pt.Tag.TagName == tag));

            query = query.OrderByDescending(p => p.CreatedAt);

            var paged = query.Skip((page - 1) * pageSize).Take(pageSize);

            var posts = await paged

                .Include(p => p.User)

                .Include(p => p.Comments)

                .ToListAsync();

            return _mapper.Map<List<PostBriefDto>>(posts);

        }

        public async Task UpdatePostAsync(Post post)

        {

            post.UpdatedAt = DateTime.UtcNow;

            _db.Posts.Update(post);

            await _db.SaveChangesAsync();

        }

        public async Task DeletePostAsync(Post post)

        {

            _db.Posts.Remove(post);

            await _db.SaveChangesAsync();

        }

        public async Task RepostAsync(int postId, int userId)

        {

            var exists = await _db.Reposts.AnyAsync(r => r.PostId == postId && r.UserId == userId);

            if (exists) return;

            var repost = new Repost

            {

                PostId = postId,

                UserId = userId,

                CreatedAt = DateTime.UtcNow

            };

            _db.Reposts.Add(repost);

            await _db.SaveChangesAsync();

        }

    }

}

// C:/Users/akars/OneDrive/Desktop/SwarPYCodes/Project_FNF-main/Project__Version1\Services\VoteService.cs
﻿using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using AutoMapper;
using Project_Version1.Data;
using Project_Version1.DTOs;

namespace Project_Version1.Services
{
    public class VoteService
    {
        private readonly FnfKnowledgeBaseContext _db;
        private readonly IMapper _mapper;

        public VoteService(FnfKnowledgeBaseContext db, IMapper mapper)
        {
            _db = db;
            _mapper = mapper;
        }

        public async Task<bool> VoteAsync(VoteDto dto, int userId)
        {
            if (dto.PostId == null && dto.CommentId == null) return false;

            var existing = await _db.Votes.FirstOrDefaultAsync(v =>
                v.UserId == userId &&
                v.PostId == dto.PostId &&
                v.CommentId == dto.CommentId);

            if (existing != null)
            {
                if (existing.VoteType == dto.VoteType)
                {
                    _db.Votes.Remove(existing);
                }
                else
                {
                    existing.VoteType = dto.VoteType;
                    existing.CreatedAt = DateTime.UtcNow;
                    _db.Votes.Update(existing);
                }
            }
            else
            {
                var vote = _mapper.Map<Vote>(dto);
                vote.UserId = userId;
                vote.CreatedAt = DateTime.UtcNow;
                _db.Votes.Add(vote);
            }

            await _db.SaveChangesAsync();
            await UpdateVoteCountersAsync(dto.PostId);
            return true;
        }

        private async Task UpdateVoteCountersAsync(int? postId)
        {
            if (!postId.HasValue) return;

            var pid = postId.Value;
            var upvotes = await _db.Votes.CountAsync(v => v.PostId == pid && v.VoteType == "Upvote");
            var downvotes = await _db.Votes.CountAsync(v => v.PostId == pid && v.VoteType == "Downvote");

            var post = await _db.Posts.FindAsync(pid);
            if (post != null)
            {
                post.UpvoteCount = upvotes;
                post.DownvoteCount = downvotes;
                _db.Posts.Update(post);
                await _db.SaveChangesAsync();
            }
        }
    }
}

